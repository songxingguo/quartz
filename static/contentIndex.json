{"advanced/architecture":{"title":"架构设计","links":["configuration","advanced/paths","layout","features/SPA-Routing","makeing-plugins"],"tags":[],"content":"Quartz是一种静态网站生成器。它是如何工作的？\n最好通过跟踪用户（您！）在命令行中运行npx quartz build 时发生的情况来回答这个问题：\n服务器端\n\n在运行npx quartz build,后，npm将查看“package.json”，以找到入口文件 ./quartz/bootstrap-cli.mjs 。\n这个文件有一个解释器 行，告诉npm使用Node执行它。\nbootstrap-cli.mjs负责以下几件事：\n\n使用yargs.分析命令行参数。\n使用esbuild 将Quartz的其余部分（位于Typescript中）转换并绑定到常规JavaScript. 这里的esbuild 配置有点特殊，因为它还使用esbuild-sass-plugin v2处理.scss 文件导入. 此外，我们捆绑组件使用自定义esbuild 插件声明的“inline”客户端脚本（任何.inline.ts 文件），该插件运行另一个esbuild 实例，该实例是浏览器而不是node环境。这两种类型的模块都以纯文本形式导入。\n如果设置了--serve，则运行本地预览服务器。这将启动两个服务器：\n\n端口3001上的WebSocket服务器，用于处理热更新加载信号。这会跟踪所有入站连接，并在检测到服务器端更改（内容或配置）时发送“rebuild”消息。\n用户定义端口（通常为8080）上的HTTP文件服务器，用于提供实际的网站文件。\n\n\n如果设置了--serve 标志，它还会启动文件观察器来检测源代码更改（例如，任何.ts、.tsx、.scss或打包程序文件）。在更改时，我们使用esbuild的rebuild API 重新生成模块（上面的第2步），这大大减少了构建时间。\n在传输主Quartz构建模块（quartz/build.ts）后，我们将其写入缓存文件.quartz-cache/transpiled-build.mjs ，然后使用await import(cacheFile)动态导入。然而，我们需要非常聪明地了解如何避免Node的导入缓存。因此，我们添加了一个随机查询字符串去欺骗Node，以为它是一个新模块。然而，这确实会导致内存泄漏，所以我们只希望用户不要在一个会话中多次热重新加载他们的配置 :)) （每次重新加载时会泄漏约350kB的内存）。导入模块后，我们调用它，传入我们之前解析的命令行参数以及一个回调函数，以向客户端发出刷新信号。\n\n\n在build.ts中，我们首先手动安装 source map 支持，以解决我们之前介绍的查询字符串缓存破解问题。然后，我们开始处理内容：\n\n清理输出目录。\n按照.gitignore递归遍历 content文件夹中的所有文件。\n分析Markdown文件。\n\nQuartz检测可用线程的数量，如果要解析的内容超过128条，则选择生成工作线程（粗略启发式）。如果需要派生worker，它将再次调用esbuild来转换worker脚本quartz/worker.ts。然后，主线程workerpool 创建128个文件的批，并将其分配给工作线程。\n每个工作线程（如果没有并发，则仅为主线程）创建一个统一基于定义的插件的解析器configuration.\n解析有三个步骤：\n\n将文件读取到vfile中。\n对内容应用插件定义的文本转换。\nSlugify文件路径并将其存储在文件的数据中。有关路径逻辑如何在Quartz中工作的更多详细信息，请参阅paths页面（剧透：它很复杂）。\n使用备注解析 进行标记解析（从文本到mdast).\n使用插件定义的Markdown-to-Markdown转换器。\n使用remark-rehype将Markdown转换为HTML（从mdast到hast）.\n使用插件定义的HTML-to-HTML转换器。\n\n\n\n\n使用插件过滤掉不需要的内容。\n使用插件输出文件。\n\n收集每个emitter插件声明的所有静态资源（例如外部CSS、JS模块等）。\n转换HTML文件的emitters在这里需要做一些额外的工作，因为它们需要转换hast并在在解析步骤中生成到JSX。在Precact运行时，使用hast-util-to-jsx-runtime完成。最后，使用preact-render-to-string将JSX呈现为HTML。它静态地将JSX呈现为HTML（即不关心“useState”、“useEffect”或任何其他React/Precact交互位）。在这里，我们还做了一些有趣的事情，比如从quartz.layout.ts组装页面layout ，组装所有实际发送到客户端的内联脚本，以及所有transpiled样式。这个逻辑的大部分可以在quartz/components/renderPage.tsx中找到。其他有趣的事情值得注意：\n\nCSS使用Lightning CSS 进行缩小和转换，去添加浏览器前缀并向下兼容。\n脚本分为beforeDOMLoaded 和afterDOMLoaded ，并分别插入 &lt;head&gt;和 &lt;body&gt;中。\n\n\n最后，每个emitter插件都负转换并将自己转换的文件写入磁盘。\n\n\n如果检测到--serve 标志，我们还会设置另一个文件观察程序来检测内容更改（仅限“.md”文件）。我们保留了一个内容映射，用于跟踪每个阶段的解析AST和插件数据，并在文件更改时进行更新。新添加或修改的路径将重新生成并添加到内容映射中。然后，所有过滤器和发射器都在生成的内容映射上运行。此文件观察程序以250ms的阈值防止抖动。成功后，我们使用传入的回调函数发送客户端刷新信号。\n\n\n\n客户端\n\n浏览器打开Quartz页面并加载HTML。&lt;head&gt; 还链接到页面样式（关联到public/index.css）和页面关键JS（关联到public/prescript.js）\n然后，一旦加载了主体，浏览器就会加载非关键JS（关联到public/postscript.js）\n页面加载完成后，页面将发送一个自定义合成浏览器事件&quot;nav&quot;。这样，组件声明的客户端脚本就可以 ‘setup’ 任何需要访问页面DOM的内容。\n\n如果在中启用了enableSPA optionconfiguration, 这个&quot;nav&quot;事件也会在任何客户端导航上触发，以允许组件注销和重新注册任何事件处理程序和状态。\n如果不是，我们将&quot;nav&quot;事件连接到页面加载后只触发一次，以允许在SPA和非SPA上下文中设置状态的方式保持一致。\n\n\n\n插件系统的架构和设计在这里故意留下了模糊的地方，因为这在makeing your own plugin指南中有更深入的描述。"},"advanced/creating-components":{"title":"创建自己的 Quartz组件","links":["makeing-plugins","features/SPA-Routing","configuration"],"tags":[],"content":"\n\n                  \n                  Warning\n                  \n                \n本指南假设您有编写JavaScript的经验，并且熟悉TypeScript。\n\n通常在网页上，我们使用HTML编写布局代码，如下所示：\n&lt;article&gt;\n  &lt;h1&gt;An article header&lt;/h1&gt;\n  &lt;p&gt;Some content&lt;/p&gt;\n&lt;/article&gt;\n这段HTML表示一篇文章，其前导标题为“文章标题”，段落包含文本“某些内容”。这与CSS相结合来设计页面样式，与JavaScript相结合来增加交互性。\n然而，HTML不允许您创建可重复使用的模板。如果你想创建一个新页面，你需要复制并粘贴上面的片段，并自己编辑标题和内容。如果我们的网站上有很多内容共享很多类似的布局，那就不太好了。创建React的聪明人也有类似的抱怨，他们发明了组件的概念——返回JSX的JavaScript函数——来解决代码重复问题。\n实际上，组件允许您编写一个JavaScript函数，该函数接受一些数据并生成HTML作为输出虽然Quartz不使用React，但它使用了相同的组件概念，允许您在Quartz网站中轻松表达布局模板\n示例组件\nConstructor\n组件文件是在quartz/components文件夹中的.tsx 文件中编写的。这些内容以quartz/components/index.ts 的形式重新导出，因此您可以更容易地在布局和其他组件中使用它们。\n每个组件文件都应有一个满足QuartzComponentConstructor 函数签名的默认导出。这是一个接受单个可选参数opts并返回Quartz组件的函数。参数opts的类型由接口Options定义，您作为组件创建者也可以自定义。\n在组件中，可以使用配置选项中的值来更改组件内部的渲染行为。例如，如果favouriteNumber选项低于0，则不会呈现下面代码段中的组件。\ninterface Options {\n  favouriteNumber: number\n}\n \nconst defaultOptions: Options = {\n  favouriteNumber: 42,\n}\n \nexport default ((userOpts?: Options) =&gt; {\n  const opts = { ...userOpts, ...defaultOpts }\n  function YourComponent(props: QuartzComponentProps) {\n    if (opts.favouriteNumber &lt; 0) {\n      return null\n    }\n \n    return &lt;p&gt;My favourite number is {opts.favouriteNumber}&lt;/p&gt;\n  }\n \n  return YourComponent\n}) satisfies QuartzComponentConstructor\nProps\nQuartz组件本身（上面突出显示的第11-17行）看起来像React组件。它接受属性（有时称为props)并返回JSX。\n所有Quartz组件都接受相同的props：\nquartz/components/types.ts// simplified for sake of demonstration\nexport type QuartzComponentProps = {\n  fileData: QuartzPluginData\n  cfg: GlobalConfiguration\n  tree: Node&lt;QuartzPluginData&gt;\n  allFiles: QuartzPluginData[]\n  displayClass?: &quot;mobile-only&quot; | &quot;desktop-only&quot;\n}\n\nfileData: 任何元数据插件都可能已添加到当前页面。\n\nfileData.slug: 当前页面的唯一标识。\nfileData.frontmatter: 任何已解析的模版（frontmatter）。\n\n\ncfg: quartz.config.ts中的 configuration 字段。\ntree: 在处理和转换文件之后的HTML AST结果。如果您想使用hast-util-to-jsx-runtime 来呈现内容，这将非常有用（您可以在quarter/components/pages/Content.tsx中找到一个例子）。\nallFiles: 已分析的所有文件的元数据。用于列出页面或了解整个网站结构。\ndisplayClass: 一个实用的class，指示用户关于如何在移动或桌面设置中渲染它的偏好。如果你想有条件地隐藏移动设备或桌面上的组件，这很有帮助。一个实用程序类，指示用户关于如何在移动或桌面设置中渲染它的偏好。如果你想有条件地隐藏移动设备或桌面上的组件，这很有帮助。\n\nStyling\nQuartz组件还可以在实际功能组件上定义一个.css 属性，该属性将由Quartz获取。这应该是一个CSS字符串，可以内联，也可以从.scss 文件导入。\n请注意，内联样式必须为普通CSS：\nquartz/components/YourComponent.tsxexport default (() =&gt; {\n  function YourComponent() {\n    return &lt;p class=&quot;red-text&quot;&gt;Example Component&lt;/p&gt;\n  }\n \n  YourComponent.css = `\n  p.red-text {\n    color: red;\n  }\n  `\n \n  return YourComponent\n}) satisfies QuartzComponentConstructor\n但是，导入的样式可以来自SCSS文件：\nquartz/components/YourComponent.tsx// assuming your stylesheet is in quartz/components/styles/YourComponent.scss\nimport styles from &quot;./styles/YourComponent.scss&quot;\n \nexport default (() =&gt; {\n  function YourComponent() {\n    return &lt;p&gt;Example Component&lt;/p&gt;\n  }\n \n  YourComponent.css = styles\n  return YourComponent\n}) satisfies QuartzComponentConstructor\n\n\n                  \n                  Warning\n                  \n                \nQuartz不使用CSS模块，所以您在这里声明的任何样式都应用于_全局_。如果您只希望它应用于您的组件，请确保使用特定的类名和选择器。\n\nScripts 和交互\n互动性呢？例如，假设您想要添加一个点击处理程序。与组件上的.css 属性一样，您也可以声明 .beforeDOMLoaded 和 .afterDOMLoaded 属性，它们是包含脚本的字符串。\nquartz/components/YourComponent.tsxexport default (() =&gt; {\n  function YourComponent() {\n    return &lt;button id=&quot;btn&quot;&gt;Click me&lt;/button&gt;\n  }\n \n  YourComponent.beforeDOM = `\n  console.log(&quot;hello from before the page loads!&quot;)\n  `\n \n  YourComponent.afterDOM = `\n  document.getElementById(&#039;btn&#039;).onclick = () =&gt; {\n    alert(&#039;button clicked!&#039;)\n  }\n  `\n  return YourComponent\n}) satisfies QuartzComponentConstructor\n\n\n                  \n                  Hint\n                  \n                \n对于来自React的组件，Quartz组件与React组件的不同之处在于，它只使用JSX进行模板和布局。 useEffect、 useState,等挂钩不会被呈现，接受onClick 处理程序等函数的其他属性也不会工作。相反，可以使用直接修改DOM元素的常规JS脚本来完成。\n\n顾名思义，.beforeDOMLoaded 脚本是在页面加载完成之前执行的，因此它无法访问页面上的任何元素。这主要用于预取任何关键数据。\n页面完全加载后，将执行.afterDOMLoaded脚本。这是一个很好的地方，可以设置任何应该在访问期间持续存在的东西（例如，从本地存储中获得一些东西）。\n如果您需要创建一个afterDOMLoaded 脚本，该脚本依赖于导航到新页面时可能更改的特定元素，则可以侦听每当加载页面时触发的 &quot;nav&quot; 事件（如果启用了SPA Routing，则可能在导航时发生）。\ndocument.addEventListener(&quot;nav&quot;, () =&gt; {\n  // do page specific logic here\n  // e.g. attach event listeners\n  const toggleSwitch = document.querySelector(&quot;#switch&quot;) as HTMLInputElement\n  toggleSwitch.addEventListener(&quot;change&quot;, switchTheme)\n  window.addCleanup(() =&gt; toggleSwitch.removeEventListener(&quot;change&quot;, switchTheme))\n})\n最佳做法是通过window.addCleanup 跟踪任何事件处理程序，以防止内存泄漏。\n这将在页面导航中调用。\n导入代码\n当然，在组件中将代码写成字符串文字并不总是实用的（也不可取！）。\nQuartz支持通过 .inline.ts文件导入组件代码。\nquartz/components/YourComponent.tsx// @ts-ignore: typescript doesn&#039;t know about our inline bundling system\n// so we need to silence the error\nimport script from &quot;./scripts/graph.inline&quot;\n \nexport default (() =&gt; {\n  function YourComponent() {\n    return &lt;button id=&quot;btn&quot;&gt;Click me&lt;/button&gt;\n  }\n \n  YourComponent.afterDOM = script\n  return YourComponent\n}) satisfies QuartzComponentConstructor\nquartz/components/scripts/graph.inline.ts// any imports here are bundled for the browser\nimport * as d3 from &quot;d3&quot;\n \ndocument.getElementById(&quot;btn&quot;).onclick = () =&gt; {\n  alert(&quot;button clicked!&quot;)\n}\n此外，与上面的示例一样，您可以导入`.inline.ts’文件中的包。这将由Quartz绑定并包含在实际脚本中。\n使用组件\n创建自定义组件后，将其重新导出到 quartz/components/index.ts中：\nquartz/components/index.tsimport ArticleTitle from &quot;./ArticleTitle&quot;\nimport Content from &quot;./pages/Content&quot;\nimport Darkmode from &quot;./Darkmode&quot;\nimport YourComponent from &quot;./YourComponent&quot;\n \nexport { ArticleTitle, Content, Darkmode, YourComponent }\nThen, you can use it like any other component in quartz.layout.ts via Component.YourComponent(). See the layout section for more details.\n然后，您可以通过Component.YourComponent()像使用quartz.layout.ts中的任何其他组件一样使用它。请参阅布局部分了解更多详细信息。\n由于Quartz组件只是返回React组件的函数，您可以在其他Quartz部件中使用它们。\nquartz/components/AnotherComponent.tsximport YourComponent from &quot;./YourComponent&quot;\n \nexport default (() =&gt; {\n  function AnotherComponent(props: QuartzComponentProps) {\n    return (\n      &lt;div&gt;\n        &lt;p&gt;It&#039;s nested!&lt;/p&gt;\n        &lt;YourComponent {...props} /&gt;\n      &lt;/div&gt;\n    )\n  }\n \n  return AnotherComponent\n}) satisfies QuartzComponentConstructor\n\n\n                  \n                  Hint\n                  \n                \n在 quartz/components中查找更多石英组件示例，作为您自己组件的参考！\n"},"advanced/index":{"title":"高级","links":[],"tags":[],"content":""},"advanced/making-plugins":{"title":"定义你自己的插件","links":["build","configuration","advanced/paths","plugins/Latex","创建组件"],"tags":[],"content":"\n\n                  \n                  Warning\n                  \n                \n这部分文档将假设您具有TypeScript的工作知识，并将包括描述Quartz插件的界面的代码片段。\n\nQuartz的插件是对内容的一系列转换。这在下面的处理管道图中进行了说明：\n\n所有插件都被定义为一个函数，该函数接受选项type OptionType = object | undefined 的单个参数，并返回与插件类型相对应的对象。\ntype OptionType = object | undefined\ntype QuartzPlugin&lt;Options extends OptionType = undefined&gt; = (opts?: Options) =&gt; QuartzPluginInstance\ntype QuartzPluginInstance =\n  | QuartzTransformerPluginInstance\n  | QuartzFilterPluginInstance\n  | QuartzEmitterPluginInstance\n以下部分将详细介绍每种插件类型可以实现的方法。在此之前，让我们先澄清几个更模糊的类型：\n\nBuildCtx是在 quartz/ctx.ts中定义的。它包括\n\nargv: 传递给Quartzbuild 命令的命令行参数\ncfg: Quartz全部configuration\nallSlugs: 所有有效内容的slugs的列表（有关“ServerSlug”的详细信息，请参阅paths ）\n\n\nStaticResources在quartz/resources.tsx.中定义。它包括\n\ncss: 应加载的样式表的URL列表\njs: 应该加载的脚本列表。脚本是用 JSResource 类型描述的，该类型也在 quartz/resources.tsx中定义。它允许您定义加载时间（在加载DOM之前或之后），它是否应该是一个模块，以及脚本的地址URL或内联内容。\n\n\n\nTransformers\n在内容上的转换（Transformers）映射，获取Markdown文件并输出修改后的内容或向文件本身添加元数据。\nexport type QuartzTransformerPluginInstance = {\n  name: string\n  textTransform?: (ctx: BuildCtx, src: string | Buffer) =&gt; string | Buffer\n  markdownPlugins?: (ctx: BuildCtx) =&gt; PluggableList\n  htmlPlugins?: (ctx: BuildCtx) =&gt; PluggableList\n  externalResources?: (ctx: BuildCtx) =&gt; Partial&lt;StaticResources&gt;\n}\n所有转换器插件都必须至少定义一个name 字段来注册插件和一些可选函数，这些函数允许您转换单个Markdown文件的各个部分。\n\ntextTransform 在文件解析到Markdown AST之前执行text-to-text的转换。\nmarkdownPlugins 定义了一个 remark plugins列表。 remark是一种以结构化方式将Markdown转换为Markdown的工具。\nhtmlPlugins 定义rehype plugins的列表。 类似于remark 的工作原理，rehype 是一种以结构化方式将HTML转换为HTML的工具。\nexternalResources 定义插件可能需要在客户端加载的任何外部资源，以使其正常工作。\n\n通常，对于remark 和rehype，您可以找到并使用的现有插件。如果你想创建自己的remark 或rehype插件，请查看创建插件指南使用 unified （底层AST解析器和转换器库）。\n借用remark 和 rehype 生态系统的转换器插件的一个很好的例子是Late插件：\nquartz/plugins/transformers/latex.tsimport remarkMath from &quot;remark-math&quot;\nimport rehypeKatex from &quot;rehype-katex&quot;\nimport rehypeMathjax from &quot;rehype-mathjax/svg&quot;\nimport { QuartzTransformerPlugin } from &quot;../types&quot;\n \ninterface Options {\n  renderEngine: &quot;katex&quot; | &quot;mathjax&quot;\n}\n \nexport const Latex: QuartzTransformerPlugin&lt;Options&gt; = (opts?: Options) =&gt; {\n  const engine = opts?.renderEngine ?? &quot;katex&quot;\n  return {\n    name: &quot;Latex&quot;,\n    markdownPlugins() {\n      return [remarkMath]\n    },\n    htmlPlugins() {\n      if (engine === &quot;katex&quot;) {\n        // if you need to pass options into a plugin, you\n        // can use a tuple of [plugin, options]\n        return [[rehypeKatex, { output: &quot;html&quot; }]]\n      } else {\n        return [rehypeMathjax]\n      }\n    },\n    externalResources() {\n      if (engine === &quot;katex&quot;) {\n        return {\n          css: [\n            // base css\n            &quot;cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css&quot;,\n          ],\n          js: [\n            {\n              // fix copy behaviour: github.com/KaTeX/KaTeX/blob/main/contrib/copy-tex/README.md\n              src: &quot;cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js&quot;,\n              loadTime: &quot;afterDOMReady&quot;,\n              contentType: &quot;external&quot;,\n            },\n          ],\n        }\n      } else {\n        return {}\n      }\n    },\n  }\n}\ntransformer插件会做的另一件常见的事情是解析一个文件并为该文件添加额外的数据：\nexport const AddWordCount: QuartzTransformerPlugin = () =&gt; {\n  return {\n    name: &quot;AddWordCount&quot;,\n    markdownPlugins() {\n      return [\n        () =&gt; {\n          return (tree, file) =&gt; {\n            // tree is an `mdast` root element\n            // file is a `vfile`\n            const text = file.value\n            const words = text.split(&quot; &quot;).length\n            file.data.wordcount = words\n          }\n        },\n      ]\n    },\n  }\n}\n \n// tell typescript about our custom data fields we are adding\n// other plugins will then also be aware of this data field\ndeclare module &quot;vfile&quot; {\n  interface DataMap {\n    wordcount: number\n  }\n}\n最后，您还可以使用unist-util-visit 包中的visit 函数或mdast-util-find-and-replace 包的findAndReplace函数对Markdown或HTML AST执行转换。\nexport const TextTransforms: QuartzTransformerPlugin = () =&gt; {\n  return {\n    name: &quot;TextTransforms&quot;,\n    markdownPlugins() {\n      return [() =&gt; {\n        return (tree, file) =&gt; {\n          // replace _text_ with the italics version\n          findAndReplace(tree, /_(.+)_/, (_value: string, ...capture: string[]) =&gt; {\n            // inner is the text inside of the () of the regex\n            const [inner] = capture\n            // return an mdast node\n            // github.com/syntax-tree/mdast\n            return {\n              type: &quot;emphasis&quot;,\n              children: [{ type: &#039;text&#039;, value: inner }]\n            }\n          })\n \n         // remove all links (replace with just the link content)\n         // match by &#039;type&#039; field on an mdast node\n         // github.com/syntax-tree/mdast#link in this example\n          visit(tree, &quot;link&quot;, (link: Link) =&gt; {\n            return {\n              type: &quot;paragraph&quot;\n              children: [{ type: &#039;text&#039;, value: link.title }]\n            }\n          })\n        }\n      }]\n    }\n  }\n}\n所有转换插件都可以在 quartz/plugins/transformers下找到。如果您决定编写自己的transformer插件，请不要忘记在quartz/plugins/transformers/index.ts下重新导出它。\n临别之词：transformer插件非常复杂，所以如果你不能马上得到它们，不要担心。看看内置的转换器，看看它们是如何对内容进行操作的，以便更好地了解如何完成您想要做的事情。\nFilters\nFilters用于过滤内容，获取所有转换器的输出，并确定实际保留哪些文件和丢弃哪些文件。\nexport type QuartzFilterPlugin&lt;Options extends OptionType = undefined&gt; = (\n  opts?: Options,\n) =&gt; QuartzFilterPluginInstance\n \nexport type QuartzFilterPluginInstance = {\n  name: string\n  shouldPublish(ctx: BuildCtx, content: ProcessedContent): boolean\n}\n过滤器插件必须定义一个name字段和一个shouldPublish 函数，该函数接收已由所有转换器处理的一段内容，并根据是否应将其传递给发射器插件返回true 或 false 。\n例如，这里有一个用于删除草稿的内置插件：\nquartz/plugins/filters/draft.tsimport { QuartzFilterPlugin } from &quot;../types&quot;\n \nexport const RemoveDrafts: QuartzFilterPlugin&lt;{}&gt; = () =&gt; ({\n  name: &quot;RemoveDrafts&quot;,\n  shouldPublish(_ctx, [_tree, vfile]) {\n    // uses frontmatter parsed from transformers\n    const draftFlag: boolean = vfile.data?.draft ?? false\n    return !draftFlag\n  },\n})\nEmitters\nEmitters减少内容，获取所有转换和过滤内容的列表，并创建输出文件。\nexport type QuartzEmitterPlugin&lt;Options extends OptionType = undefined&gt; = (\n  opts?: Options,\n) =&gt; QuartzEmitterPluginInstance\n \nexport type QuartzEmitterPluginInstance = {\n  name: string\n  emit(ctx: BuildCtx, content: ProcessedContent[], resources: StaticResources): Promise&lt;FilePath[]&gt;\n  getQuartzComponents(ctx: BuildCtx): QuartzComponent[]\n}\nemitter插件必须定义一个name 字段、一个emit 函数和一个 getQuartzComponents 函数，emit负责查看所有解析和过滤的内容，然后适当地创建文件，并返回插件创建的文件的路径列表。\n可以通过常规节点fs module创建新文件（即fs.cp 或 fs.writeFile），或者如果您正在创建包含文本的文件，则通过quartz/plugins/emitters/helpers.ts中的write函数。write具有以下签名：\nexport type WriteOptions = (data: {\n  // the build context\n  ctx: BuildCtx\n  // the name of the file to emit (not including the file extension)\n  slug: ServerSlug\n  // the file extension\n  ext: `.${string}` | &quot;&quot;\n  // the file content to add\n  content: string\n}) =&gt; Promise&lt;FilePath&gt;\n这是一个关于写入适当的输出文件夹并确保中间目录存在的精简包装。如果您选择使用本机节点fsAPI，请确保也向argv.output文件夹发出。\n如果您正在创建一个需要渲染组件的emitter插件，还需要注意三件事：\n\n您的组件应该使用getQuartzComponents 来声明用于构造页面的QuartzComponents 列表。请参阅上的页面创建组件 了解更多信息。\n您可以使用quartz/components/renderPage.tsx 中定义的 renderPage 函数将quartz组件渲染为HTML。\n如果需要将HTML AST呈现到JSX，可以使用quartz/util/jsx.ts.中的htmlToJsx函数。这方面的一个例子可以在quartz/components/pages/Content.tsx.中找到。\n\n例如，以下是内容页面插件的简化版本，用于呈现每个页面。\nquartz/plugins/emitters/contentPage.tsxexport const ContentPage: QuartzEmitterPlugin = () =&gt; {\n  // construct the layout\n  const layout: FullPageLayout = {\n    ...sharedPageComponents,\n    ...defaultContentPageLayout,\n    pageBody: Content(),\n  }\n  const { head, header, beforeBody, pageBody, left, right, footer } = layout\n  return {\n    name: &quot;ContentPage&quot;,\n    getQuartzComponents() {\n      return [head, ...header, ...beforeBody, pageBody, ...left, ...right, footer]\n    },\n    async emit(ctx, content, resources, emit): Promise&lt;FilePath[]&gt; {\n      const cfg = ctx.cfg.configuration\n      const fps: FilePath[] = []\n      const allFiles = content.map((c) =&gt; c[1].data)\n      for (const [tree, file] of content) {\n        const slug = canonicalizeServer(file.data.slug!)\n        const externalResources = pageResources(slug, resources)\n        const componentData: QuartzComponentProps = {\n          fileData: file.data,\n          externalResources,\n          cfg,\n          children: [],\n          tree,\n          allFiles,\n        }\n \n        const content = renderPage(cfg, slug, componentData, opts, externalResources)\n        const fp = await emit({\n          content,\n          slug: file.data.slug!,\n          ext: &quot;.html&quot;,\n        })\n \n        fps.push(fp)\n      }\n      return fps\n    },\n  }\n}\n请注意，它采用了FullPageLayout作为选项。它是通过将SharedLayout 和PageLayout 组合而成的，两者都是通过quartz.layout.ts 文件提供的。\n\n\n                  \n                  Hint\n                  \n                \n在quartz/plugins中查找更多石英中的插件示例，作为您自己插件的参考！\n"},"advanced/paths":{"title":"Quartz中的路径","links":[],"tags":[],"content":"路径很难推理，因为特别是对于静态站点生成器来说，它们可能来自很多地方。\n一段内容的完整文件路径？也是一条路径。用slug代表一段内容怎么样？还有另一条路。\n把这些都键入string 并称之为一天是愚蠢的，因为不小心把一种类型的路径误认为另一种类型是很常见的。不幸的是，TypeScript对于类型别名没有nominal types ，这意味着即使您自定义了服务器端slug或客户端slug的类型，您仍然可以意外地将其中一个分配给另一个，而TypeScript不会捕捉到它。\n幸运的是，我们可以使用brands模拟 nominal typing 。\n// instead of\ntype FullSlug = string\n \n// we do\ntype FullSlug = string &amp; { __brand: &quot;full&quot; }\n \n// that way, the following will fail typechecking\nconst slug: FullSlug = &quot;some random string&quot;\n虽然这可以防止在我们的nominal typing系统中出现大多数输入错误（例如，将服务器slug误认为客户端slug），但这并不能防止我们在强制转换字符串时将字符串误认为客户端的slug。\n因此，当从在“entrypoints”中将字符串转换为这些nominal types之一时，我们仍然需要小心，如下图中的六边形所示。\n下图绘制了所有路径源、nominal path types之间的关系，以及quartz/path.ts 中它们之间转换的函数。\ngraph LR\n    Browser{{Browser}} --&gt; Window{{Body}} &amp; LinkElement{{Link Element}}\n    Window --&quot;getFullSlug()&quot;--&gt; FullSlug[Full Slug]\n    LinkElement --&quot;.href&quot;--&gt; Relative[Relative URL]\n    FullSlug --&quot;simplifySlug()&quot; --&gt; SimpleSlug[Simple Slug]\n    SimpleSlug --&quot;pathToRoot()&quot;--&gt; Relative\n    SimpleSlug --&quot;resolveRelative()&quot; --&gt; Relative\n    MD{{Markdown File}} --&gt; FilePath{{File Path}} &amp; Links[Markdown links]\n    Links --&quot;transformLink()&quot;--&gt; Relative\n    FilePath --&quot;slugifyFilePath()&quot;--&gt; FullSlug[Full Slug]\n    style FullSlug stroke-width:4px\n\n以下是slugs的主要类型，并对每种类型的路径进行了粗略描述：\n\nFilePath: 磁盘上文件的真实文件路径。不能是相对的，并且必须具有文件扩展名。\nFullSlug: 不能是相对的，并且不能有前导斜杠或尾随斜杠。它可以有index作为它的最后一个段。尽可能使用这个，因为这是对slug最“一般”的解释。\nSimpleSlug：不能是相对的，并且不应将/index 作为结尾或文件扩展名。但是，它可以有一个尾部斜线来指示文件夹路径。\nRelativeURL: 必须以.开头或表示它是一个相对URL。不应该以/index作为结尾或文件扩展名，但可以包含尾部斜杠。\n\n为了更清楚地了解它们之间的关系，请查看quartz/path.test.ts中的路径测试。"},"authoring-content":{"title":"创作内容","links":["/","build","features/callouts","features/wikilinks","features/private-pages","setting-up-your-GitHub-repository","plugins/Frontmatter","plugins/CreatedModifiedDate","plugins/Description"],"tags":[],"content":"Quartz中的所有内容都应放在/content文件夹中。Quartz主页的内容位于content/index.md.中。如果你已经有setup Quartz，该文件夹应该已经被初始化了。此文件夹中的任何Markdown都将由Quartz处理。\n建议您使用Obsidian作为编辑和维护Quartz的一种方式。它提供了一个不错的编辑器和图形界面，用于预览、编辑和链接您的本地文件和附件。\n一切都安排好了吗？让我们build并在本地预览您的Quartz！\n语法\n由于Quartz使用Markdown文件作为编写内容的主要方式，因此它完全支持Markdown语法。默认情况下，Quartz还附带了一些语法扩展，如Github风格的Markdown（脚注、删除线、表格、任务列表）和 Obsidian风格的Markdown （callouts, wikilinks）。\n此外，Quartz还允许您在名为frontmatter的笔记中指定其他元数据。\ncontent/note.md---\ntitle: Example Title\ndraft: false\ntags:\n  - example-tag\n---\n \nThe rest of your content lives here. You can use **Markdown** here :)\n一些常见的由Quartz原生支持的frontmatter字段：\n\ntitle: 页面的标题。如果没有提供，Quartz将使用文件名作为标题。\ndescription: 用于链接预览的说明。\naliases: 笔记的其他名称。为字符串列表。\ntags: 笔记的标签。\ndraft: 是否发布页面。这是在Quartz中创建private pages的一种方法。\ndate: 表示发布日期的字符串。通常使用“YYYY-MM-DD”格式。\n\n同步您的内容\n当你的Quartz达到你满意的程度时，你可以将你的更改保存到GitHub。\n首先，确保你已经已经设置了你的GitHub存储库，然后执行npx quartz sync。\n自定义\ntitle、 tags、 aliases 和cssclasses的Frontmatter解析是Frontmatter插件的一项功能，date由CreatedModifiedDate插件处理，“description”由Description插件处理。有关自定义选项，请参阅插件页面。"},"build":{"title":"构建Quartz","links":["/"],"tags":[],"content":"一旦你有了初始化的Quartz，让我们看看它在本地是什么样子的：\nnpx quartz build --serve\n这将启动一个本地web服务器，在您的计算机上运行Quartz。打开web浏览器并访问http://localhost:8080/查看它。\n\n\n                  \n                  标志和选项 \n                  \n                \n有关完整的帮助选项，您可以运行npx-quarter-build--help。\n其中大多数都有合理的默认值，但如果您有自定义设置，则可以覆盖它们：\n\n-d or --directory: 内容文件夹。通常都是content\n-v or --verbose: 打印出额外的日志信息\n-o or --output: 输出文件夹。通常都是`public“\n--serve: 运行本地热更新加载服务器以预览Quartz\n--port: 运行本地预览服务器的端口\n--concurrency: 要使用多少个线程来分析笔记\n\n"},"configuration":{"title":"配置","links":["layout","RSS订阅","features/SPA-Routing","features/popover-previews","features/i18n","hosting","features/private-pages","features/graph-view","features/syntax-highlighting","tags/plugin/transformer","tags/plugin/filter","tags/plugin/emitter","plugins/ExplicitPublish","plugins/Latex","tags/plugin","advanced/making-plugins"],"tags":[],"content":"Quartz是非常可配置的，即使你不知道任何编码。您需要的大部分配置都可以通过编辑quartz.layout.ts或更改layout来完成。\n\n\n                  \n                  Tip\n                  \n                \n如果您使用具有TypeScript语言支持（如VSCode）的文本编辑器编辑Quartz配置，当您在配置中出错时，它会警告您，帮助您避免配置错误！\n\nQuartz的配置可分为两个主要部分：\nquartz.config.tsconst config: QuartzConfig = {\n  configuration: { ... },\n  plugins: { ... },\n}\n常规配置\n这部分配置涉及任何可能影响整个站点的内容。以下是您可以配置的所有内容的列表：\n\npageTitle: 网站的标题。这也用于为您的网站生成 RSS订阅。\nenableSPA: 是否在您的网站上启用SPA Routing 。\nenablePopovers: 是否在您的网站上启用popover previews。\nanalytics: 用于网站分析的内容。值可以是：\n\nnull: 不使用分析；\n{ provider: &#039;google&#039;, tagId: &#039;&lt;your-google-tag&gt;&#039; }: 使用谷歌分析；\n{ provider: &#039;plausible&#039; } (managed) or { provider: &#039;plausible&#039;, host: &#039;&lt;your-plausible-host&gt;&#039; } (self-hosted): use Plausible;\n{ provider: &#039;umami&#039;, host: &#039;&lt;your-umami-host&gt;&#039;, websiteId: &#039;&lt;your-umami-website-id&gt;&#039; }: 使用 Umami;\n{ provider: &#039;goatcounter&#039;, websiteId: &#039;my-goatcounter-id&#039; } (managed) or { provider: &#039;goatcounter&#039;, websiteId: &#039;my-goatcounter-id&#039;, host: &#039;my-goatcounter-domain.com&#039;, scriptSrc: &#039;my-url.to/counter.js&#039; } (self-hosted) 使用 GoatCounter\n{ provider: &#039;posthog&#039;, apiKey: &#039;&lt;your-posthog-project-apiKey&gt;&#039;, host: &#039;&lt;your-posthog-host&gt;&#039; }: 使用 Posthog;\n\n\nlocale: 用于i18n和日期格式。\nbaseUrl: 这用于需要绝对URL才能知道网站的规范“主页”所在位置的网站地图和RSS源。这通常是您网站的已部署URL（例如，此网站的“quartz.jzhao.xyz”）。不要包含协议（即“https://”）或任何前导或尾随斜杠。\n\n如果你在没有发布到自定义域的GitHub页面上，这也应该包括子路径。例如，如果我的存储库是jackyzha0/quartz，GitHub页面将部署到jackyzha0.github.io/quartz并且 baseUrl 将是jackyzha0.github.io/quartz。\n请注意，Quartz 4将尽可能避免使用此功能，并尽可能使用相对URL，以确保您的网站无论在哪里实际部署都能正常工作。\n\n\nignorePatterns: 忽略文件列表，Quartz在 content 文件夹中查找文件时应忽略这些模式而不进行搜索。有关详细信息，请参阅private pages。\ndefaultDateType: 是否将创建、修改或发布作为默认日期显示在页面和页面列表中。\ntheme: 配置网站的外观。\n\ncdnCaching: 如果为true（默认值），请使用Google CDN缓存字体。这通常会更快。如果您希望Quartz下载独立的字体，请禁用（“false”）此选项。\ntypography: 使用什么字体。Google Fonts 上任何的字体都可用。\n\nheader: 用于页眉的字体\ncode: 代码的字体。\nbody: 所有内容的字体。\n\n\ncolors: 控制网站的主题。\n\nlight: 页面背景\nlightgray: 边框\ngray: 图形链接，较重的边框\ndarkgray: 正文\ndark: 标题文本和图标\nsecondary: 链接颜色，当前graph节点\ntertiary: 悬停状态和访问的graph节点\nhighlight: 内部链接背景，高亮显示的文本，高亮显示的代码行\n\n\n\n\n\n插件\n您可以将Quartz插件视为对内容的一系列转换。\n\nquartz.config.tsplugins: {\n  transformers: [...],\n  filters: [...],\n  emitters: [...],\n}\n\nTransformers 映射内容（例如解析frontmatter、生成描述）\nFilters 过滤内容（例如过滤掉草稿）\nEmitters 减少过度内容（例如，创建RSS提要或列出带有特定标签的所有文件的页面）\n\n您可以通过在transformers、filters 和 emitters 字段中添加、删除和重新排序插件来自定义Quartz的行为。\n\n\n                  \n                  Note\n                  \n                \n每个transformer按顺序修改每个节点。有些转换器是位置敏感的，所以你可能需要特别注意它们是否需要在某些其他插件之前或之后出现。\n\n您应该注意将插件添加到与其插件类型相对应的正确条目中。例如，要添加ExplicitPublish插件（Filter），您需要添加以下行：\nquartz.config.tsfilters: [\n  ...\n  Plugin.ExplicitPublish(),\n  ...\n],\n要删除一个插件，您应该删除quartz.config.ts中出现的所有插件。\n为了进一步自定义插件，一些插件可能也有自己的配置设置，你可以传入。如果你不传入配置，插件将使用其默认设置。\n例如，Latex 插件允许您传入一个指定renderEngine的字段，以便在Katex和MathJax之间进行选择。\nquartz.config.tstransformers: [\n  Plugin.FrontMatter(), // use default options\n  Plugin.Latex({ renderEngine: &quot;katex&quot; }), // set some custom options\n]\n一些插件默认包含在 quartz.config.ts中，还有更多可用的。\n您可以看到所有插件及其配置选项的列表here。\n如果你想制作自己的插件，请参阅制作自定义插件指南。"},"features/Docker-Support":{"title":"Docker 支持","links":[],"tags":[],"content":"Quartz附带了一个Docker镜像，可以让您在不安装Node的情况下在本地预览Quartz。\n您可以在Docker中运行下面的行来运行Quartz。\ndocker run --rm -itp 8080:8080 $(docker build -q .)"},"features/Latex":{"title":"LaTeX","links":["plugins/Latex"],"tags":["feature/transformer"],"content":"Quartz uses Katex by default to typeset both inline and block math expressions at build time.\nQuartz默认情况下支持Katex，在构建时对内联和块数学表达式进行类型设置。\n语法\n数学表达式块\n块数学可以通过用 $$分隔数学表达式来呈现。\n$$\nf(x) = \\int_{-\\infty}^\\infty\n    f\\hat(\\xi),e^{2 \\pi i \\xi x}\n    \\,d\\xi\n$$\n\nf(x)=∫−∞∞​f(^​ξ),e2πiξxdξ\na​=b+c=e+f​\n[1a​2b​3c​]\nEψEf(x)​=Hψ=−2mℏ2​∂x2∂2​ψ+21​mωx2ψ=−2mℏ2​[4k2x2f(x)+2(−2kx)f′(x)+f′′(x)]e−kx2+21​mωx2f(x)e−kx2⇓=−2mℏ2​[4k2x2f(x)−4kxf′(x)+f′′(x)]+21​mωx2f(x)=−2mℏ2​[−4kxf′(x)+f′′(x)]​Expanding the Hamiltonian OperatorUsing the ansatz ψ(x)=e−kx2f(x), hoping to cancel the x2 termRemoving the e−kx2 term from both sidesChoosing k=2im​ℏω​​ to cancel the x2 term, via −2mℏ2​4k2=21​mω​\n\n\n                  \n                  Warn\n                  \n                \n由于基础解析库的限制，Quartz中的块数学要求$$ 分隔符位于换行符上，如上所述。\n\n行内数学表达式\n类似地，可以通过用单个$分隔数学表达式来呈现内联数学。例如，$e^{i\\pi} = -1$ 生成 eiπ=−1\n转义字符\n在某些情况下，一个段落中可能同时包含多个$，这可能会意外触发MathJax/Katex。\n为了避免这种情况，你可以通过做\\$ 来避开美元符号。\n例如：\n\n不正确： I have $1 and you have $2产生 I have 1andyouhave2\n正确: I have \\$1 and you have \\$2 产生 I have $1 and you have $2\n\n使用 mhchem\n将以下导入添加到quartz/plugins/transformers/latex.ts 的顶部（在所有其他导入之前）：\nquartz/plugins/transformers/latex.tsimport &quot;katex/contrib/mhchem&quot;\n自定义\nLatex解析是Late插件的一个功能。有关自定义选项，请参阅插件页面。"},"features/Mermaid-diagrams":{"title":"图表","links":["features/Obsidian-compatibility","plugins/ObsidianFlavoredMarkdown","plugins/SyntaxHighlighting"],"tags":["feature/transformer"],"content":"Quartz支持Mermaid，它允许您在笔记中添加图表。Mermaid支持一系列图表，如流程图，序列图，和时间表. 这是作为Obsidian compatibility的一部分启用的，可以从该插件进行配置和启用/禁用。\n默认情况下，Quartz将渲染图表以匹配网站主题。\n\n\n                  \n                  Warning\n                  \n                \n想知道为什么即使启用了Mermaid，它们也可能不会显示？您可能需要对插件进行重新排序，使ObsidianFlavoredMarkdown在SyntaxHighlighting之后。\n\n语法\n要添加Mermaid，请创建一个Mermaid代码块。\n```mermaid\nsequenceDiagram\n    Alice-&gt;&gt;+John: Hello John, how are you?\n    Alice-&gt;&gt;+John: John, can you hear me?\n    John--&gt;&gt;-Alice: Hi Alice, I can hear you!\n    John--&gt;&gt;-Alice: I feel great!\n```\n\nsequenceDiagram\n    Alice-&gt;&gt;+John: Hello John, how are you?\n    Alice-&gt;&gt;+John: John, can you hear me?\n    John--&gt;&gt;-Alice: Hi Alice, I can hear you!\n    John--&gt;&gt;-Alice: I feel great!\n"},"features/Obsidian-compatibility":{"title":"Obsidian兼容性","links":["plugins/ObsidianFlavoredMarkdown","features/wikilinks","features/Mermaid-diagrams","plugins/Frontmatter","plugins/CrawlLinks","Frontmater"],"tags":["feature/transformer"],"content":"Quartz最初是作为一种工具设计的，用于将Obsidian vaults发布为网站。尽管Quartz的范围随着时间的推移而扩大，但它并没有失去与Obsidian无缝互操作的能力。\n默认情况下，Quartz附带ObsidianFlavoredMarkdown插件，这是一个转换器插件，增加了对Obsidian Flavored Markdown的支持。这包括对wikilinks和Mermaid diagrams.\n它还附带了对frontmatter parsing的支持，并使用与Obsidian通过Frontmatter转换器插件使用的字段相同的字段。\n最后，Quartz还提供了CrawlLinks插件，允许您自定义Quartz的链接解析行为以匹配Obsidian。\n配置\n此功能由ObsidianFlavoredMarkdown、Frontmater和CrawlLinks插件提供。有关自定义选项，请参阅插件页面。"},"features/OxHugo-compatibility":{"title":"OxHugo 兼容性","links":["plugins/OxHugoFlavoredMarkdown"],"tags":["feature/transformer"],"content":"org-roam 是emacs.的纯文本个人知识管理系统。 ox-hugo是组织导出器后端，将 org-mode 文件导出到兼容Markdown的Hugo 。\n因为ox-hugo生成的Markdown不是纯Markdown，而是hugo特有的，所以我们需要将其转换为Quartz。这是由OxHugoFlavoredMarkdown插件完成的。尽管这个插件是在考虑ox-hugo 的情况下编写的，但它应该适用于任何特定于hugo的Markdown。\nquartz.config.tsplugins: {\n  transformers: [\n    Plugin.FrontMatter({ delims: &quot;+++&quot;, language: &quot;toml&quot; }), // if toml frontmatter\n    // ...\n    Plugin.OxHugoFlavouredMarkdown(),\n    Plugin.GitHubFlavoredMarkdown(),\n    // ...\n  ],\n},\n用法\nQuartz默认不理解org-roam 文件，因为它们不是Markdown。您负责使用像ox-hugo 这样的外部工具将org-roam 文件作为Markdown内容导出到Quartz，并管理静态资产，使其在最终输出中可用。\n配置\n此功能由OxHugoFlavoredMarkdown插件提供。有关自定义选项，请参阅插件页面。"},"features/RSS-Feed":{"title":"RSS 订阅","links":["configuration","plugins/ContentIndex"],"tags":[],"content":"Quartz通过生成RSS阅读器可以订阅的“index.xml”文件，为您网站上的所有内容发送RSS提要。由于RSS规范，这需要您的configuration以便RSS阅读器正确地拾取它。\n配置\n此功能由ContentIndex插件提供。有关自定义选项，请参阅插件页面。"},"features/SPA-Routing":{"title":"单页路由","links":["configuration"],"tags":[],"content":"单页应用程序风格的渲染。这可以防止未格式化内容的闪烁，并提高Quartz的平滑度。\n在后台，这是通过劫持页面导航来实现的，而不是通过GET 请求获取HTML，然后使用 micromorph 来区分和选择性地替换页面的部分。这使我们可以在不完全刷新页面的情况下更改页面的内容，从而减少浏览器需要加载的内容量。\n配置\n\n禁用SPA路由：在configuration quartz.config.ts中设置的enableSPA字段false。\n"},"features/backlinks":{"title":"反向链接","links":["features/popover-previews"],"tags":["component"],"content":"一个笔记的反向链接是从另一个笔记到该笔记的链接。如果启用了丰富的popover previews 功能，则反向链接窗格中的链接也具有该功能。\n自定义\n\n删除反向链接：从quartz.layout.ts删除Component.Backlinks() 。\n组件: quartz/components/Backlinks.tsx\n样式: quartz/components/styles/backlinks.scss\n脚本: quartz/components/scripts/search.inline.ts\n"},"features/breadcrumbs":{"title":"面包屑导航","links":["layout"],"tags":["component"],"content":"Breadcrumb提供了一种使用其父文件夹列表在网站内浏览页面层次结构的方法。\n默认情况下，页面最顶部的元素是面包屑导航栏（也可以在该页面的顶部看到！）。\n自定义\n大多数配置都可以通过将选项传递给Component.Breadcrumbs()。\n例如，以下是默认配置的样子：\nquartz.layout.tsComponent.Breadcrumbs({\n  spacerSymbol: &quot;❯&quot;, // symbol between crumbs\n  rootName: &quot;Home&quot;, // name of first/root element\n  resolveFrontmatterTitle: true, // whether to resolve folder names through frontmatter titles\n  hideOnRoot: true, // whether to hide breadcrumbs on root `index.md` page\n  showCurrentPage: true, // whether to display the current page in the breadcrumbs\n})\n在传递自己的选项时，如果希望保留这些字段的默认值，则可以省略其中的任何或全部字段。\n也可以通过调整layout （向上或向下移动Component.Breadcrumbs()）\n想进一步定制吗？\n\n删除面包屑：从quarter.layout.ts中删除Component.Breadcrumbs() 。\n组件: quartz/components/Breadcrumbs.tsx\n样式: quartz/components/styles/breadcrumbs.scss\n脚本: 内联在 quartz/components/Breadcrumbs.tsx\n"},"features/callouts":{"title":"标注语法","links":["plugins/ObsidianFlavoredMarkdown","plugins/SyntaxHighlighting"],"tags":["feature/transformer"],"content":"Quartz支持与Obsidian相同的警告标注语法。\n这包括\n\n12种不同的标注类型（每种都有多个别名）\n可折叠标注\n\n&gt; [!info] Title\n&gt; \n&gt; This is a callout!\n\n请参阅此处的支持类型和语法文档。\n\n\n                  \n                  Warning\n                  \n                \n想知道为什么即使启用了callout也不会显示？您可能需要对插件进行重新排序，让ObsidianFlavoredMarkdown在SyntaxHighlighting之后。\n\n自定义\ncallout是ObsidianFlavoredMarkdown插件的一个功能。请参阅插件页面，了解如何启用或禁用它们。\n您可以通过自定义quartz/styles/callouts.scss来编辑图标。\n添加自定义标注\n默认情况下，通过应用note样式来处理自定义标注。要制作精美的，您必须将这些行添加到custom.scss中。\nquartz/styles/custom.scss.callout {\n  &amp;[data-callout=&quot;custom&quot;] {\n    --color: #customcolor;\n    --border: #custombordercolor;\n    --bg: #custombg;\n    --callout-icon: url(&quot;data:image/svg+xml; utf8, &lt;custom formatted svg&gt;&quot;); //SVG icon code\n  }\n}\n\n\n                  \n                  Warning\n                  \n                \n在将SVG放入CSS之前，不要忘记确保它是URL编码的。你可以使用像this one 这样的工具帮助你做到这一点。\n\n示例\n\n\n                  \n                  Info\n                  \n                \nDefault title\n\n\n\n                  \n                  Can callouts be nested?\n                  \n                \n\n\n                  \n                  Yes!, they can. And collapsed! \n                  \n                \n\n\n                  \n                  You can even use multiple layers of nesting. \n                  \n                \n\n\n\n\n\n                  \n                  Note\n                  \n                \nAliases: “note”\n\n\n\n                  \n                  Abstract\n                  \n                \nAliases: “abstract”, “summary”, “tldr”\n\n\n\n                  \n                  Info\n                  \n                \nAliases: “info”\n\n\n\n                  \n                  Todo\n                  \n                \nAliases: “todo”\n\n\n\n                  \n                  Tip\n                  \n                \nAliases: “tip”, “hint”, “important”\n\n\n\n                  \n                  Success\n                  \n                \nAliases: “success”, “check”, “done”\n\n\n\n                  \n                  Question\n                  \n                \nAliases: “question”, “help”, “faq”\n\n\n\n                  \n                  Warning\n                  \n                \nAliases: “warning”, “attention”, “caution”\n\n\n\n                  \n                  Failure\n                  \n                \nAliases: “failure”, “missing”, “fail”\n\n\n\n                  \n                  Danger\n                  \n                \nAliases: “danger”, “error”\n\n\n\n                  \n                  Bug\n                  \n                \nAliases: “bug”\n\n\n\n                  \n                  Example\n                  \n                \nAliases: “example”\n\n\n\n                  \n                  Quote\n                  \n                \nAliases: “quote”, “cite”\n"},"features/darkmode":{"title":"深色模式","links":[],"tags":["component"],"content":"Quartz支持开箱即用的深色模式，尊重用户的主题偏好。暗模式开关的任何未来手动切换都将保存在浏览器的本地存储中，以便在未来的页面加载中保持不变。\n自定义\n\n删除暗模式：从quartery.layout.ts中删除Component.Darkmode()。\n组件: quartz/components/Darkmode.tsx\n样式: quartz/components/styles/darkmode.scss\n脚本: quartz/components/scripts/darkmode.inline.ts\n\n您还可以收听themechange事件，以便在主题更改时执行任何自定义逻辑。\ndocument.addEventListener(&quot;themechange&quot;, (e) =&gt; {\n  console.log(&quot;Theme changed to &quot; + e.detail.theme) // either &quot;light&quot; or &quot;dark&quot;\n  // your logic here\n})"},"features/explorer":{"title":"资源管理器","links":["layout","authoring-content","features/table-of-contents"],"tags":["component"],"content":"Quartz具有一个资源管理器，允许您浏览网站上的所有文件和文件夹。它支持嵌套文件夹，并且可高度自定义。\n默认情况下，它显示页面上的所有文件夹和文件。要在其他位置显示资源管理器，可以编辑layout.\n文件夹的显示名称由folder/index.md 中的元数据中的title字段确定（更多详细信息请参阅authoring content）。如果此文件不存在或不包含元数据，则将使用本地文件夹名称。\n\n\n                  \n                  Info\n                  \n                \n资源管理器默认使用本地存储来保存资源管理器的状态。这样做是为了确保在导航到不同页面时获得流畅的体验。\n要从本地存储中清除/删除资源管理器状态，请删除fileTree 条目（有关如何在基于铬的浏览器中从本地存储删除密钥的指南，请参见此处)。您可以通过传递useSavedState: false 作为参数来禁用此功能。\n\n自定义\n大多数配置都可以通过将选项传递给Component.Explorer()。\n例如，以下是默认配置的样子：\nquartz.layout.tsComponent.Explorer({\n  title: &quot;Explorer&quot;, // title of the explorer component\n  folderClickBehavior: &quot;collapse&quot;, // what happens when you click a folder (&quot;link&quot; to navigate to folder page on click or &quot;collapse&quot; to collapse folder on click)\n  folderDefaultState: &quot;collapsed&quot;, // default state of folders (&quot;collapsed&quot; or &quot;open&quot;)\n  useSavedState: true, // whether to use local storage to save &quot;state&quot; (which folders are opened) of explorer\n  // Sort order: folders first, then files. Sort folders and files alphabetically\n  sortFn: (a, b) =&gt; {\n    ... // default implementation shown later\n  },\n  filterFn: filterFn: (node) =&gt; node.name !== &quot;tags&quot;, // filters out &#039;tags&#039; folder\n  mapFn: undefined,\n  // what order to apply functions in\n  order: [&quot;filter&quot;, &quot;map&quot;, &quot;sort&quot;],\n})\n在传递自己的选项时，如果希望保留这些字段的默认值，则可以省略其中的任何或全部字段。\n想进一步定制吗？\n\n删除资源管理器：从 quartz.layout.ts 中删除 Component.Explorer()\n\n（可选）：删除资源管理器组件后，可以将table of contents组件移回布局的“左”部分\n\n\n更改“排序”、“筛选”和“映射”行为：在高级自定义中解释\n组件:\n\n包装器（外部组件、生成文件树等）：quarter/components/Explorer.tsx\n资源管理器节点（递归，文件夹或文件）：quartz/components/ExplorerNode.tsx\n\n\n样式: quartz/components/styles/explorer.scss\n脚本: quartz/components/scripts/explorer.inline.ts\n\n高级自定义\n此组件允许您完全自定义其所有行为。您可以传递自定义的“排序”、“筛选”和“映射”函数。\n您可以传递的所有函数都使用FileNode 类，该类具有以下属性：\nquartz/components/ExplorerNode.tsxexport class FileNode {\n  children: FileNode[]  // children of current node\n  name: string  // last part of slug\n  displayName: string // what actually should be displayed in the explorer\n  file: QuartzPluginData | null // if node is a file, this is the file&#039;s metadata. See `QuartzPluginData` for more detail\n  depth: number // depth of current node\n \n  ... // rest of implementation\n}\n您可以传递的每个函数都是可选的。默认情况下，只会使用“排序”功能：\nDefault sort function// Sort order: folders first, then files. Sort folders and files alphabetically\nComponent.Explorer({\n  sortFn: (a, b) =&gt; {\n    if ((!a.file &amp;&amp; !b.file) || (a.file &amp;&amp; b.file)) {\n      // sensitivity: &quot;base&quot;: Only strings that differ in base letters compare as unequal. Examples: a ≠ b, a = á, a = A\n      // numeric: true: Whether numeric collation should be used, such that &quot;1&quot; &lt; &quot;2&quot; &lt; &quot;10&quot;\n      return a.displayName.localeCompare(b.displayName, undefined, {\n        numeric: true,\n        sensitivity: &quot;base&quot;,\n      })\n    }\n    if (a.file &amp;&amp; !b.file) {\n      return 1\n    } else {\n      return -1\n    }\n  },\n})\n\n您可以为sortFn、 filterFn 和 mapFn传递自己的函数。所有功能将按照order 选项提供的顺序执行（请参见自定义）。这些函数的行为与它们的 Array.prototype 对应函数类似，只是它们修改了整个FileNode树，而不是返回一个新的树。\n有关如何使用sort、filter 和 map的更多信息，可以查看Array.prototype.sort（），Array.prototype.filter（）和Array.prototype.map（）。\n类型定义如下所示：\nsortFn: (a: FileNode, b: FileNode) =&gt; number\nfilterFn: (node: FileNode) =&gt; boolean\nmapFn: (node: FileNode) =&gt; void\n\n\n                  \n                  Tip\n                  \n                \n您可以检查FileNode 是文件夹还是类似的文件：\nif (node.file) {\n  // node is a file\n} else {\n  // node is a folder\n}\n\n基础示例\nThese examples show the basic usage of sort, map and filter.\n使用“sort将文件放在第一位\n使用此示例，资源管理器将按字母顺序对所有内容进行排序，但将所有文件置于所有文件夹之上。\nquartz.layout.tsComponent.Explorer({\n  sortFn: (a, b) =&gt; {\n    if ((!a.file &amp;&amp; !b.file) || (a.file &amp;&amp; b.file)) {\n      return a.displayName.localeCompare(b.displayName)\n    }\n    if (a.file &amp;&amp; !b.file) {\n      return -1\n    } else {\n      return 1\n    }\n  },\n})\n更改显示名称（map）\n使用此示例，所有FileNodes （文件夹+文件）的显示名称将转换为大写。\nquartz.layout.tsComponent.Explorer({\n  mapFn: (node) =&gt; {\n    node.displayName = node.displayName.toUpperCase()\n  },\n})\n删除元素列表（filter）\n使用此示例，您可以通过使用omit 集提供文件夹/文件的数组来从资源管理器中删除元素。\nquartz.layout.tsComponent.Explorer({\n  filterFn: (node) =&gt; {\n    // set containing names of everything you want to filter out\n    const omit = new Set([&quot;authoring content&quot;, &quot;tags&quot;, &quot;hosting&quot;])\n    return !omit.has(node.name.toLowerCase())\n  },\n})\n您可以通过更改omit 集合的条目来进行自定义。只需添加所有要删除的文件夹或文件名。\n按标记删除文件\n您可以通过node.file?。这允许您根据文件的主题过滤掉文件，例如通过它们的标签。\nquartz.layout.tsComponent.Explorer({\n  filterFn: (node) =&gt; {\n    // exclude files with the tag &quot;explorerexclude&quot;\n    return node.file?.tags?.includes(&quot;explorerexclude&quot;) !== true\n  },\n})\n在资源管理器中显示每个元素\n要覆盖从资源管理器中删除tags 文件夹的默认筛选功能，可以将筛选功能设置为undefined.。\nquartz.layout.tsComponent.Explorer({\n  filterFn: undefined, // apply no filter function, every file and folder will visible\n})\n高级示例\n\n\n                  \n                  Tip\n                  \n                \n当编写更复杂的函数时，layout文件可能会开始显得非常局促。\n可以通过在另一个文件中定义函数来解决此问题。\nfunctions.tsimport { Options } from &quot;./quartz/components/ExplorerNode&quot;\nexport const mapFn: Options[&quot;mapFn&quot;] = (node) =&gt; {\n  // implement your function here\n}\nexport const filterFn: Options[&quot;filterFn&quot;] = (node) =&gt; {\n  // implement your function here\n}\nexport const sortFn: Options[&quot;sortFn&quot;] = (a, b) =&gt; {\n  // implement your function here\n}\n然后可以像这样导入它们：\nquartz.layout.tsimport { mapFn, filterFn, sortFn } from &quot;./functions.ts&quot;\nComponent.Explorer({\n  mapFn: mapFn,\n  filterFn: filterFn,\n  sortFn: sortFn,\n})\n\n添加表情符号前缀\n添加表情符号前缀(📁 对于文件夹，📄 对于文件），您可以使用这样的映射函数：\nquartz.layout.tsComponent.Explorer({\n  mapFn: (node) =&gt; {\n    // dont change name of root node\n    if (node.depth &gt; 0) {\n      // set emoji for file/folder\n      if (node.file) {\n        node.displayName = &quot;📄 &quot; + node.displayName\n      } else {\n        node.displayName = &quot;📁 &quot; + node.displayName\n      }\n    }\n  },\n})\n把它们放在一起\n在本例中，我们将使用上述示例中的函数来自定义资源管理器：添加表情符号前缀、[[#删除元素列表filter|删除元素列表（filter）]]和[[#使用sort将文件放在第一位|使用“sort将文件放在第一位]]。\nquartz.layout.tsComponent.Explorer({\n  filterFn: sampleFilterFn,\n  mapFn: sampleMapFn,\n  sortFn: sampleSortFn,\n  order: [&quot;filter&quot;, &quot;sort&quot;, &quot;map&quot;],\n})\n请注意我们是如何在此处自定义order数组的。这样做是因为默认顺序最后应用order函数。虽然这通常工作得很好，但由于我们更改了所有显示名称的第一个字符，因此会导致意外行为。在我们的示例中，将基于表情符号前缀而不是第一个_真实_字符来应用排序。\n为了解决这个问题，我们只是更改了顺序，并在更改map 函数中的显示名称之前应用了sort 函数。\n将sort 与预定义的排序顺序一起使用\n这里是另一个例子，其中包含文件/文件夹名称（作为slugs）的映射用于在quartz中定义资源管理器的排序顺序。所有未在nameOrderMap 中列出的文件/文件夹都将显示在该文件夹层次结构级别的顶部。\nIt’s also worth mentioning, that the smaller the number set in nameOrderMap, the higher up the entry will be in the explorer. Incrementing every folder/file by 100, makes ordering files in their folders a lot easier. Lastly, this example still allows you to use a mapFn or frontmatter titles to change display names, as it uses slugs for nameOrderMap (which is unaffected by display name changes).\n还值得一提的是，nameOrderMap中设置的数字越小，资源管理器中的条目就越高。将每个文件夹/文件增加100，可以更容易地对文件夹中的文件进行排序。最后，此示例仍然允许您使用mapFn或元数据title来更改显示名称，因为它使用nameOrderMap的slugs（不受显示名称更改的影响）。\nquartz.layout.tsComponent.Explorer({\n  sortFn: (a, b) =&gt; {\n    const nameOrderMap: Record&lt;string, number&gt; = {\n      &quot;poetry-folder&quot;: 100,\n      &quot;essay-folder&quot;: 200,\n      &quot;research-paper-file&quot;: 201,\n      &quot;dinosaur-fossils-file&quot;: 300,\n      &quot;other-folder&quot;: 400,\n    }\n \n    let orderA = 0\n    let orderB = 0\n \n    if (a.file &amp;&amp; a.file.slug) {\n      orderA = nameOrderMap[a.file.slug] || 0\n    } else if (a.name) {\n      orderA = nameOrderMap[a.name] || 0\n    }\n \n    if (b.file &amp;&amp; b.file.slug) {\n      orderB = nameOrderMap[b.file.slug] || 0\n    } else if (b.name) {\n      orderB = nameOrderMap[b.name] || 0\n    }\n \n    return orderA - orderB\n  },\n})\n作为参考，以下是quartz资源管理器窗口在该示例中的样子：\n📖 Poetry Folder\n📑 Essay Folder\n    ⚗️ Research Paper File\n🦴 Dinosaur Fossils File\n🔮 Other Folder\n\n这就是文件结构的样子：\nindex.md\npoetry-folder\n    index.md\nessay-folder\n    index.md\n    research-paper-file.md\ndinosaur-fossils-file.md\nother-folder\n    index.md\n"},"features/folder-and-tag-listings":{"title":"文件夹和标签列表","links":["advanced/","authoring-content","tags/plugin","tags/component","plugins/FolderPage","plugins/TagPage"],"tags":["feature/emitter","component"],"content":"Quartz会为您拥有的任何文件夹和标签生成列表页面。\n文件夹列表\nQuartz将为该文件夹下的所有页面生成一个索引页面。这包括多个层次的任何内容。\n此外，Quartz还将为子文件夹生成页面。假设您在嵌套文件夹content/abc/def/note.md中有一个笔记。然后Quartz将为abc 下的所有笔记生成一个页面，并为abc/def下的全部笔记生成一页。\n您可以通过引用文件夹列表的名称和尾部斜杠链接到该列表，如下所示：[[advanced/]]（结果为advanced）。\n默认情况下，Quartz会将页面命名为Folder: &lt;folder name&gt; ，而没有说明。您可以通过在具有title的文件夹中创建一个index.md 文件来覆盖它元数据字段。您在此文件中写入的任何内容也将用于文件夹描述中。\n例如，对于文件夹content/posts，您可以添加另一个文件content/posts/index.md t来为其添加特定的描述。\n标签列表\nQuartz还将为您的vault中的每个唯一标签创建一个索引页面，并呈现带有该标签的所有笔记的列表。\nQuartz还支持标记层次结构（例如plugin/emitter），并且还将为标记层次结构的每个级别呈现单独的标记页面。它还将在/tags处创建一个默认的全局标记索引页面，显示Quartz中所有标记的列表。\n您可以通过引用带有tag/前缀的标签列表来链接到该标签列表，如下所示：[[tags/plugin]]（结果为plugin）。\n与文件夹列表一样，您也可以通过为每个标记创建一个文件来提供标记页面的描述和标题。例如，如果您想为component 标记创建一个自定义描述，您可以在content/tags/component.md中创建一个带有标题和描述的文件。\n自定义\n文件夹列表是FolderPage插件的一个功能，TagPage插件中的标记列表。有关自定义选项，请参阅插件页面。"},"features/full-text-search":{"title":"全文搜索","links":["configuration"],"tags":["component"],"content":"Quartz中的全文搜索由Flexsearch提供支持。它足够快，可以在不到10ms的时间内返回50万个单词的Quartz的搜索结果。\n它可以通过点击搜索栏或按⌘/ctrl + K打开。每个查询都会显示前5个搜索结果。突出显示匹配的子句，并摘录最相关的30个单词。单击搜索结果将导航到该页面。\n要按标签搜索内容，您可以按⌘/ctrl + shift + K ，也可以用#（例如#components）开始查询。\n该组件也可以通过键盘访问：Tab和Shift+Tab将在搜索结果中前后循环，Enter将导航到高亮显示的结果（默认情况下为第一个结果）。您还可以使用“向上箭头”和“向下箭头”导航搜索结果。\n\n\n                  \n                  Info\n                  \n                \n搜索要求ContentIndex 生成插件存在于configuration.\n\n索引行为\n默认情况下，它会对网站上的每个页面进行索引，删除Markdown语法。这意味着链接URL（例如）没有索引。\n它正确地标记中文、韩语和日语字符，并为标题、内容和标签构建单独的索引，在内容匹配之上权衡标题匹配。\n自定义\n\n删除搜索：从 quartery.layout.ts中删除Component.Search()。\n组件: quartz/components/Search.tsx\n样式: quartz/components/styles/search.scss\n脚本: quartz/components/scripts/search.inline.ts\n\n您可以编辑contextWindowWords、numSearchResults 或 numTagResults 以满足您的需要\n\n\n"},"features/graph-view":{"title":"关系图谱","links":["configuration"],"tags":["component"],"content":"Quartz features a graph-view that can show both a local graph view and a global graph view.\nQuartz具有一个关系图谱，可以显示局部关系和全局关系。\n\n局部关系图谱显示链接到当前文件或从当前文件链接的文件。换言之，它显示了最多一跳的所有笔记。\n单击局部关系图谱右上角的图形图标可以切换全局图形视图。它显示了所有笔记以及它们是如何相互连接的。\n\n默认情况下，笔记半径与该文件的传入和传出内部链接的总数成比例。\n此外，与浏览器以不同颜色突出显示访问过的链接类似，关系图谱也将以不同颜色显示您访问过的节点。\n\n\n                  \n                  Info\n                  \n                \n关系图谱要求ContentIndex 生成器插件存在于configuration中。\n\n自定义\nMost configuration can be done by passing in options to Component.Graph().\n大多数配置都可以通过将选项传递给Component.Graph()。\n例如，以下是默认配置的样子：\nquartz.layout.tsComponent.Graph({\n  localGraph: {\n    drag: true, // whether to allow panning the view around\n    zoom: true, // whether to allow zooming in and out\n    depth: 1, // how many hops of notes to display\n    scale: 1.1, // default view scale\n    repelForce: 0.5, // how much nodes should repel each other\n    centerForce: 0.3, // how much force to use when trying to center the nodes\n    linkDistance: 30, // how long should the links be by default?\n    fontSize: 0.6, // what size should the node labels be?\n    opacityScale: 1, // how quickly do we fade out the labels when zooming out?\n    removeTags: [], // what tags to remove from the graph\n    showTags: true, // whether to show tags in the graph\n  },\n  globalGraph: {\n    drag: true,\n    zoom: true,\n    depth: -1,\n    scale: 0.9,\n    repelForce: 0.5,\n    centerForce: 0.3,\n    linkDistance: 30,\n    fontSize: 0.6,\n    opacityScale: 1,\n    removeTags: [], // what tags to remove from the graph\n    showTags: true, // whether to show tags in the graph\n  },\n})\n在传递自己的选项时，如果希望保留这些字段的默认值，则可以省略其中的任何或全部字段。\n想进一步定制吗？\n\n删除关系图谱：从quartz.layout.ts中删除Component.Graph() 。\n组件: quartz/components/Graph.tsx\n样式: quartz/components/styles/graph.scss\n脚本: quartz/components/scripts/graph.inline.ts\n"},"features/i18n":{"title":"国际化","links":["configuration"],"tags":[],"content":"国际化允许用户将Quartz界面中的文本翻译成各种支持的语言，而无需进行大量的代码更改。这可以通过更改configuration quartz.config.ts中的locale字段。\n区域设置字段通常遵循特定的格式：{language}-｛REGION｝\n\n{language} 通常是2-字母小写语言代码.\n{REGION} 通常是2-字母大写的地区代码\n\n\n\n                  \n                  有兴趣贡献吗？ \n                  \n                \n我们很高兴欢迎翻译公关! 要进行翻译，请执行以下操作：\n\n在 quartz/i18n/locales 文件夹中，复制en-US.ts 文件。\n将其重命名为{language}-｛REGION｝.ts，因此它与上面显示的格式的区域设置相匹配。\n填写翻译！\n在quartz/i18n/index.ts中的TRANSLATIONS下添加条目。\n\n"},"features/index":{"title":"功能列表","links":[],"tags":[],"content":""},"features/popover-previews":{"title":"弹出式预览","links":["创建组件","images/quartz-layout.png"],"tags":[],"content":"就像维基百科一样，当你把鼠标悬停在Quartz中的一个链接上时，会弹出一个页面预览，你可以滚动查看整个内容。指向标题的链接也会滚动弹出窗口，在视图中显示特定的标题。\n默认情况下，由于CORS.的原因，Quartz只获取vault内页面的预览。它通过使用popover-hint 类选择所有HTML元素来实现这一点。对于大多数页面，这包括页面标题、页面元数据（如单词和阅读时间）、标记和实际页面内容。\n当自定义组件的时候，您可以将这个 popover-hint类包含在popover中。\n与Obsidian类似，使用Wiki链接引用的图像也可以作为弹出窗口查看。\n配置\n\n删除popovers：将quartz.config.ts中的enablePopovers f字段设置为false.。\n样式: quartz/components/styles/popover.scss\n脚本: quartz/components/scripts/popover.inline.ts\n"},"features/private-pages":{"title":"私有页面","links":["advanced/making-plugins","plugins/RemoveDrafts","plugins/ExplicitPublish","configuration"],"tags":["feature/filter"],"content":"您可能希望避免将某些笔记作为网站发布。Quartz通过两种可结合使用的机制来支持这一点：\n过滤器插件\nFilter plugins是根据特定标准过滤内容的插件。默认情况下，Quartz使用RemoveDrafts插件过滤掉任何在标题中有 draft: true 的笔记。\n如果您只想发布选定数量的笔记，则可以使用ExplicitPublish，它将过滤掉所有笔记，但在标题中具有publish: true的笔记除外。\n\n\n                  \n                  Warning\n                  \n                \n无论使用何种过滤插件，**所有非Markdown文件都将在最终版本中发布并公开。**这包括图像、录音、PDF等文件。防止这种情况并仍然能够嵌入本地图像的一种方法是创建一个专门用于公共媒体的文件夹，并将以下两种模式添加到ignorePatterns数组中。\n&quot;!(PublicMedia)**/!(*.md)&quot;, &quot;!(*.md)&quot;\n\nignorePatterns\n这是主目录下quartz.config.ts 中的一个字段configuration 这允许您指定一个模式列表，以有效地将其排除在一起进行解析。任何有效的fast-glob模式在这里工作。\n\n\n                  \n                  Note\n                  \n                \nBash的glob语法与fastglob的略有不同，使用Bash的语法可能会导致意外的结果。\n\n常见的例子包括：\n\nsome/folder：排除整个some/folder` 目录\n*.md：排除所有扩展名为.md的文件\n!*.md排除不具有.md扩展名的所有文件\n**/private：在任何嵌套级别排除任何名为private的文件或文件夹\n\n\n\n                  \n                  Warning\n                  \n                \n通过插件或ignorePatterns 模式将某些内容标记为私有内容只会阻止页面包含在最终构建的网站中。如果你的GitHub存储库是公共的，也一定要为Quartz的.gitignore中的存储库添加一个ignore。请参阅git文档了解更多信息。\n"},"features/recent-notes":{"title":"最近的笔记","links":["layout"],"tags":["component"],"content":"默认情况下，Quartz可以根据一些过滤和排序标准生成最近的笔记列表layout ，您可以在quartz.layout.ts中添加Component.RecentNotes。\n自定义\n\n更改标题”Recent notes”：将一个附加参数传递给Component.RecentNotes({ title: &quot;Recent writing&quot; })\n更改最近笔记的数量：将一个附加参数传递给Component.RecentNotes({ limit: 5 })\n显示“查看更多”链接：向“组件”传递一个附加参数。Component.RecentNotes({ linkToMore: &quot;tags/components&quot; })。此字段应该是已存在页面的完整slug。\n自定义筛选：将一个附加参数传递给Component.RecentNotes({ filter: someFilterFunction })。筛选函数应该是签名为(f: QuartzPluginData) =&gt; boolean.的函数。\n自定义排序：将一个附加参数传递给Component.RecentNotes({ sort: someSortFunction })。默认情况下，Quartz将按日期排序，然后以文字方式平局。排序函数应该是签名为(f1: QuartzPluginData, f2: QuartzPluginData) =&gt; number的函数。有关示例，请参阅 quartz/components/PageList.tsx 中的byDateAndAlphabetical。\n组件: quartz/components/RecentNotes.tsx\n样式: quartz/components/styles/recentNotes.scss\n"},"features/syntax-highlighting":{"title":"高亮显示语法","links":["plugins/SyntaxHighlighting"],"tags":["feature/transformer"],"content":"Quartz中的语法高亮显示完全是在构建时完成的。这意味着Quartz只提供预先计算的CSS来突出显示正确的单词，因此没有繁重的客户端捆绑包来突出显示语法。\n而且，与一些客户端荧光笔不同，它有一个完整的TextMate语法分析器，而不是使用Regex，允许高度准确的代码高亮显示。\nIn short, it generates HTML that looks exactly like your code in an editor like VS Code. Under the hood, it’s powered by Rehype Pretty Code which uses Shiki.\n简而言之，它生成的HTML与VS code等编辑器中的代码完全相似。在引擎盖下，它由Rehype Pretty Code 使用Shiki提供动力。\n\n\n                  \n                  Warning\n                  \n                \n如果你的笔记中有很多代码片段，语法高亮显示确实会影响构建速度。\n\n格式化\n一行中backticks内的文本的格式将类似于代码。\n```ts\nexport function trimPathSuffix(fp: string): string {\n  fp = clientSideSlug(fp)\n  let [cleanPath, anchor] = fp.split(&quot;#&quot;, 2)\n  anchor = anchor === undefined ? &quot;&quot; : &quot;#&quot; + anchor\n\n  return cleanPath + anchor\n}\n```\n\nexport function trimPathSuffix(fp: string): string {\n  fp = clientSideSlug(fp)\n  let [cleanPath, anchor] = fp.split(&quot;#&quot;, 2)\n  anchor = anchor === undefined ? &quot;&quot; : &quot;#&quot; + anchor\n \n  return cleanPath + anchor\n}\nTitles\n将文件标题添加到代码块中，文本位于双引号（“”）内：\n```js title=&quot;...&quot;\n\n```\n\nquartz/path.tsexport function trimPathSuffix(fp: string): string {\n  fp = clientSideSlug(fp)\n  let [cleanPath, anchor] = fp.split(&quot;#&quot;, 2)\n  anchor = anchor === undefined ? &quot;&quot; : &quot;#&quot; + anchor\n \n  return cleanPath + anchor\n}\n线条高亮显示\n将数字范围放在{}内。\n```js {1-3,4}\n\n```\n\nexport function trimPathSuffix(fp: string): string {\n  fp = clientSideSlug(fp)\n  let [cleanPath, anchor] = fp.split(&quot;#&quot;, 2)\n  anchor = anchor === undefined ? &quot;&quot; : &quot;#&quot; + anchor\n \n  return cleanPath + anchor\n}\n单词高亮显示\n一系列字符，如字面正则表达式。\n```js /useState/\nconst [age, setAge] = useState(50);\nconst [name, setName] = useState(&#039;Taylor&#039;);\n```\n\nconst [age, setAge] = useState(50)\nconst [name, setName] = useState(&quot;Taylor&quot;)\n行号\n语法高亮显示具有自动配置的行号。如果要以特定数字开始行号，请使用showLineNumbers{number}：\n```js showLineNumbers{number}\n\n```\n\nexport function trimPathSuffix(fp: string): string {\n  fp = clientSideSlug(fp)\n  let [cleanPath, anchor] = fp.split(&quot;#&quot;, 2)\n  anchor = anchor === undefined ? &quot;&quot; : &quot;#&quot; + anchor\n \n  return cleanPath + anchor\n}\n超越代码块\n您可以在代码块内部格式化代码块，方法是用比前一个栅栏多出一个倒勾的另一级倒勾栅栏包裹它。\n````\n```js /useState/\nconst [age, setAge] = useState(50);\nconst [name, setName] = useState(&#039;Taylor&#039;);\n```\n````\n\n自定义\n语法高亮显示是SyntaxHighlighting插件的一项功能。有关自定义选项，请参阅插件页面。"},"features/table-of-contents":{"title":"目录","links":["plugins/TableOfContents","layout"],"tags":["component","feature/transformer"],"content":"Quartz可以根据每页的标题列表自动生成目录（TOC）。它还将用不同的颜色突出显示您滚动过的标题，从而显示您在页面上的当前滚动位置。\n您可以通过在页面的首页添加enableToc: false来隐藏页面上的TOC。\n默认情况下，TOC显示从H1（# Title）到H3（### Title）的所有标题，并且只有当页面上有多个标题时才会显示。\n自定义\n目录是TableOfContents插件的一个功能。有关更多自定义选项，请参阅插件页面。\n它还需要TableOfContents 组件，默认情况下会显示在右侧边栏中。您可以通过自定义layout. TOC组件可以用layout 参数配置，该参数可以是modern（默认）或 legacy。"},"features/wikilinks":{"title":"Wikilinks","links":["plugins/CrawlLinks","features/Obsidian-compatibility"],"tags":[],"content":"Wikilinks是由早期的互联网Wiki开创的，它可以更容易地在页面之间编写链接，而无需每次都编写Markdown或HTML链接。\nQuartz默认支持Wikilinks，这些链接由Quartz使用CrawlLinks插件解析。请参阅内部链接上的Obsidian帮助页面，以获取有关Wikilink语法的更多信息。\n这是作为Obsidian compatibility 的一部分并且可以从该插件进行配置和启用/禁用。\n语法\n\n[[Path to file]]: 生成一个指向Path to file.md（或Path-to-file.md）的链接，其文本为Path to file\n[[Path to file | Here&#039;s the title override]]: 生成一个指向Path to file.md的链接，其文本为Here&#039;s the title override\n[[Path to file#anchor|Anchor]]: 生成指向文件Path to file.md中的锚点Anchor的链接\n[[Path to file#^block-ref|^block-ref]]: 生成指向文件Path to file.md中特定块block-ref的链接\n\n嵌入\n\n![[Path to image]]: 将图像嵌入到页面中\n![[Path to image|100x145]]: 将尺寸为100px * 145px的图像嵌入到页面中\n![[Path to file]]: 覆盖整个页面\n![[Path to file#anchor|Anchor]]: 嵌入标题Anchor下的所有内容\n![[Path to file#^b15695|^b15695]]: 嵌入包含ID为^b15695的块\n"},"hosting":{"title":"部署","links":["setting-up-your-GitHub-repository","RSS订阅","configuration"],"tags":[],"content":"Quartz有效地将您的Markdown文件和其他资源转化为HTML、JS和CSS文件的捆绑包（一个网站！）。\n然而，如果你想向全世界发布你的网站，你需要一种在线托管的方式。本指南将详细介绍如何使用常见的托管提供商进行部署，但任何允许您部署静态HTML的服务都应该同样有效。\n\n\n                  \n                  Warning\n                  \n                \n本指南的其余部分假设您已经为Quartz创建了自己的GitHub仓库。如果你还没有，请确保你这样做。\n\n\n\n                  \n                  Hint\n                  \n                \n一些Quartz功能（如RSS订阅和网站地图生成）需要在您的configuration 以正常工作。请确保在部署之前设置了此项！\n\nCloudflare Pages\n\n登录Cloudflare并选择您的帐户。\n在“帐户主页”中，选择工作人员和页面*&gt;创建应用程序&gt;页面&gt;连接到Git。\n选择您创建的新GitHub仓库，并在设置构建和部署部分提供以下信息：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConfiguration optionValueProduction branchv4Framework presetNoneBuild commandnpx quartz buildBuild output directorypublic按“保存并部署”，Cloudflare应该会在大约一分钟内部署好您的站点版本。然后，每次您将Quartz更改同步到GitHub时，您的网站都应该更新。\n要添加自定义域，请查看Cloudflare的文档.\n\n\n                  \n                  Warning\n                  \n                \nCloudflare Pages默认情况下执行浅层克隆，因此，如果您依赖“git”来获取时间戳，建议您在构建命令的开头添加 git fetch --unshallow &amp;&amp;（例如，git fetch --unshallow &amp;&amp; npx quartz build）。\n\nGitHub Pages\n在您的本地Quartz中，创建一个新文件 quartz/.github/workflows/deploy.yml。\nquartz/.github/workflows/deploy.ymlname: Deploy Quartz site to GitHub Pages\n \non:\n  push:\n    branches:\n      - v4\n \npermissions:\n  contents: read\n  pages: write\n  id-token: write\n \nconcurrency:\n  group: &quot;pages&quot;\n  cancel-in-progress: false\n \njobs:\n  build:\n    runs-on: ubuntu-22.04\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0 # Fetch all history for git info\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 18.14\n      - name: Install Dependencies\n        run: npm ci\n      - name: Build Quartz\n        run: npx quartz build\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v2\n        with:\n          path: public\n \n  deploy:\n    needs: build\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v2\n然后:\n\n前往仓库的“Settings”选项卡，在侧边栏中单击“Pages”。在“源”下，选择“GitHub Actions”。\n通过执行npx quartz sync来提交这些更改。这应该将您的网站部署到&lt;github username&gt;.github.io/&lt;repository name&gt;。\n\n\n\n                  \n                  Hint\n                  \n                \n如果您收到由于环境保护规则而不允许部署到 github-pages 的错误，请确保删除任何现有的GitHub pages 环境。\n您可以通过转到GitHub分叉上的“Settings”页面，转到“Environments”选项卡并按下trash图标来完成此操作。GitHub操作将在下次同步Quartz时为您正确地重新创建环境。\n\n\n\n                  \n                  Info\n                  \n                \nQuartz生成的文件格式为file.html，而不是 file/index.html，这意味着删除了_非文件夹路径_的尾部斜杠。由于GitHub页面不进行重定向，这可能会导致指向您的网站的现有链接使用尾部斜杠来断开。如果不破坏现有链接对您来说很重要（例如，您正在从Quartz 3迁移），请考虑使用Cloudflare Pages。\n\n自定义域名\n以下是如何将自定义域名添加到GitHub pages部署中。\n\n前往仓库的“Settings”选项卡。\n在侧边栏的“Code and automation”部分，单击“Pages”。\n在“Custom Domain”下，键入您的自定义域名，然后单击“Save”。\n下一步取决于您使用的是顶级域（example.com）还是子域名（subdomain.example.com）。\n\n如果您使用的是顶级域名，请导航到您的DNS提供商并创建一个“A”记录，将您的顶点域指向具有以下IP地址的GitHub名称服务器：\n\n185.199.108.153\n185.199.109.153\n185.199.110.153\n185.199.111.153\n\n\n如果您正在使用子域名，请导航到您的DNS提供商，并创建一个“CNAME”记录，将您的子域指向站点的默认域。例如，如果您想为您的用户站点使用子域quartz.example.com ，请创建一个“CNAME”记录，将quartz.example.com 指向&lt;github-username&gt;.github.io。\n\n\n\n\n上面显示了为“jzhao.xyz”（顶级域）和“quartz.jzhao.xyz”（子域名）配置的Google域的屏幕截图\n请参阅GitHub文档，了解如何使用GitHub Pages设置自己的自定义域名的更多细节。\n\n\n                  \n                  Why aren&#039;t my changes showing up? \n                  \n                \n您的更改没有显示可能有很多不同的原因，但最可能的原因是您忘记将更改推送到GitHub。\n确保您将更改保存到Git，并通过npx quartz sync将其同步到GitHub。这也将确保从其他设备中提取您可能进行的任何更新，以便您在本地进行更新。\n\nVercel\n处理地址\n在部署到Vercel之前，项目目录的根目录中需要一个vercel.json文件。它需要包含以下配置，这样URL就不需要“.html”扩展名：\nvercel.json{\n  &quot;cleanUrls&quot;: true\n}\n部署到 Vercel\n\n登录Vercel然后单击”Add New…” &gt; Project\n导入包含Quartz项目的Git存储库。\n为项目命名（仅限小写字符和连字符）\n检查是否设置了这些配置选项：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConfiguration optionValueFramework PresetOtherRoot 目录./Build and Output Settings &gt; Build Commandnpx quartz build\n\n按Deploy。一旦它上线，您将有2个*.vercel.app URL来查看页面。\n\n自定义域名\n\n\n                  \n                  Note\n                  \n                \n如果域中已经存在了某些内容，则在不替换以前的内容的情况下，这些步骤将不起作用。作为一种变通方法，您可以使用Next.js重写或使用下一节创建子域。\n\n\n如果有必要，请更新quartz.config.js中的baseUrl。\n跳转到 Domains - Dashboard 页面。\n将域连接到Vercel\n按“Add”将自定义域连接到Vercel。\n选择您的Quartz存储库，然后按Continue。\n输入要连接到的域名。\n按照说明更新DNS记录，直到您看到“Valid Configuration”\n\n使用子域名\n使用docs.example.com就是子域的一个例子。它们是将多个部署连接到一个域名的简单方法。\n\n如果有必要，请更新quartz.config.js中的baseUrl。\n确保您的域已添加到Domains - Dashboard的页面。\n跳转到Vercel Dashboard并选择您的Quartz项目。\n转到“Settings”选项卡，然后单击侧边栏中的“Domains”\n在字段中输入您的子域名，然后按“Add”\n\nNetlify\n\n登录Netify然后单击“Add new site”。\n选择包含Quartz项目的Git提供商和仓库。\n4.在“Build command”下，输入npx quartz Build。\n5.在“Publish directory”下，输入public。\n按Deploy。一旦它上线，您将有一个*.netlify.app 地址来查看页面。\n要添加自定义域，请选中左侧边栏中的“Domain management”，就像使用Vercel一样。\n\nGitLab Pages\n在本地Quartz中，创建一个新文件.gitlab-ci.yaml。\n.gitlab-ci.yamlstages:\n  - build\n  - deploy\n \nvariables:\n  NODE_VERSION: &quot;18.14&quot;\n \nbuild:\n  stage: build\n  rules:\n    - if: &#039;$CI_COMMIT_REF_NAME == &quot;v4&quot;&#039;\n  before_script:\n    - apt-get update -q &amp;&amp; apt-get install -y nodejs npm\n    - npm install -g n\n    - n $NODE_VERSION\n    - hash -r\n    - npm ci\n  script:\n    - npx quartz build\n  artifacts:\n    paths:\n      - public\n  cache:\n    paths:\n      - ~/.npm/\n    key: &quot;${CI_COMMIT_REF_SLUG}-node-${CI_COMMIT_REF_NAME}&quot;\n  tags:\n    - docker\n \npages:\n  stage: deploy\n  rules:\n    - if: &#039;$CI_COMMIT_REF_NAME == &quot;v4&quot;&#039;\n  script:\n    - echo &quot;Deploying to GitLab Pages...&quot;\n  artifacts:\n    paths:\n      - public\n当.gitlab-ci.yaml提交后，gitlab将以GitLab Page.的形式构建和部署网站。您可以在侧边栏的 Deploy &gt; Pages 下找到url。\n默认情况下，该页面是私有的，只有在登录到具有存储库访问权限的GitLab帐户时才可见，但可以在Deploy → Pages下的设置中打开。\n自有服务器\n将 public 目录复制到web服务器，并将其配置为提供文件。您可以使用任何web服务器来托管您的网站。由于Quartz生成的链接不包括“.html”扩展名，您需要让您的web服务器知道如何处理它。\n配置 Nginx\n以下是如何使用Nginx执行此操作的示例：\nnginx.confserver {\n    listen 80;\n    server_name example.com;\n    root /path/to/quartz/public;\n    index index.html;\n    error_page 404 /404.html;\n \n    location / {\n        try_files $uri $uri.html $uri/ =404;\n    }\n}\n配置 Caddy\n以下是如何使用Caddy进行此操作的示例：\nCaddyfileexample.com {\n    root * /path/to/quartz/public\n    try_files {path} {path}.html {path}/ =404\n    file_server\n    encode gzip\n \n    handle_errors {\n        rewrite * /{err.status_code}.html\n        file_server\n    }\n}"},"index":{"title":"欢迎来到 Quartz 4","links":["showcase","authoring-content","configuration","layout","build","setting-up-your-GitHub-repository","hosting","features/Obsidian-compatibility","features/full-text-search","features/graph-view","features/wikilinks","features/backlinks","features/Latex","features/syntax-highlighting","features/popover-previews","features/Docker-Support","features/i18n","features","advanced/creating-components","features/SPA-Routing","advanced/making-plugins","philosophy","advanced/architecture","upgrading"],"tags":[],"content":"Quartz 是一款快速、开箱即用的静态博客生成器。能将 Markdown 内容转换成功能齐全的网站。许多的学生、开发者和老师已经在使用 Quartz发布个人笔记、网站和数字花园到网上。\n🪴 快速上手\nQuartz 需要 Node 版本 v18.14 和 npm 版本 v9.3.1 以上才能正常工作。请确保您的设备上已经安装了再继续。\n然后，打开您的命令行工具，输入下面的命令：\ngit clone github.com/jackyzha0/quartz.git\ncd quartz\nnpm i\nnpx quartz create\n这将指导您初始化Quartz。完成后再进行下面的步骤：\n\n在 Quartz 中 写入内容\n修改Quartz的配置\n更改Quartz的布局\n打包并预览Quartz\n同步更新到Gihub上\n部署Quartz到线上\n\n如何您更喜欢视频形式的介绍，您可以观看Nicole van der Hoeven 的视频 video guide on how to set up Quartz!。\n🔧 功能\n\nObsidian兼容性, 全文搜索, 关系图谱, 笔记翻译, wikilinks, 反向链接, Latex, 高亮语法, 弹出式预览, Doker支持, 国际化 和 更多 开箱即用的功能。\n配置和内容的热更新\n简单的JSX布局和页面组件\n页面加载速度快得离谱并且包体积很小\n通过插件可以实现完全自定义的解析、过滤和页面生成\n\n完整的功能列表可以访问功能页面。您可以在哲学页面上阅读更多关于这些功能的信息并且在 架构设计页面了解技术概述。\n🚧 故障排除 + 更新\n有任何关于Quartz的问题？请尝试在issue中搜索。如果没有解决，请升级Quartz最新的版本查看问题是否修复。\n如果您仍然有问题，如果您觉得发现了一个bug, 请提交issue或者在我们的社区中寻求帮助。"},"layout":{"title":"布局","links":["tags/component","创建组件","configuration"],"tags":[],"content":"某些 emitters 也许会输出HTML 文件。为了更简单的自定义，这些emitters允许你完全重新安排您的页面布局。页面布局可以在 quartz.layout.ts 文件进行配置。\n每个页面都是由许多包含QuartzComponents的部分组成。下面代码列出了可以在其中添加组件的。\nquartz/cfg.tsexport interface FullPageLayout {\n  head: QuartzComponent // single component\n  header: QuartzComponent[] // laid out horizontally\n  beforeBody: QuartzComponent[] // laid out vertically\n  pageBody: QuartzComponent // single component\n  left: QuartzComponent[] // vertical on desktop, horizontal on mobile\n  right: QuartzComponent[] // vertical on desktop, horizontal on mobile\n  footer: QuartzComponent // single component\n}\n这些对应于页面的以下部分：\n\n\n\n                  \n                  Note\n                  \n                \n有两个额外的属性没有在上面的代码中展示。\n\nhead 是在HTML中渲染 &lt;head&gt; 标签 的唯一的组件。这不会直观地显示在页面上，只负责文档的元数据，如选项卡标题、脚本和样式。\nheader是一组水平排列的组件，出现在“beforeBody”部分之前。这使您能够复制旧的Quartz 3标题栏，其中包括标题、搜索栏和暗模式切换。默认情况下，Quartz 4不会在 header中放置任何组件。\n\n\nQuartz 组件与插件一样，可以采用其他属性作为配置选项。如果您熟悉React术语，您可以将其视为高阶组件。\n有关所有可用组件及其配置选项，请参见所有组件的列表 。如果您有兴趣进一步定制Quartz的行为，也可以查看创建组件指南。\n样式\n大多数的样式更改，如配色方案和字体，都可以简单地通过常规配置选项来完成。然而，如果你想进行更多的风格改变，你可以通过编写自己的样式来做到这一点。Quartz 4和Quartz 3一样使用Sass编写样式。\n您可以在 quartz/styles/base.scss 中看到基础的样式并且您可以在quartz/styles/custom.scss 中定义您自己的样式。\n\n\n                  \n                  Note\n                  \n                \n某些组件也可能提供自己的样式！例如，“quartery/components/Darkmode.tsx”从“quarter/components/styles/Darkmode.scss”导入样式。如果要自定义特定零部件的样式，请仔细检查零部件定义，查看其样式是如何定义的。\n"},"migrating-from-Quartz-3":{"title":"从Quartz 3迁移","links":["configuration","hosting","features/folder-and-tag-listings","创建组件"],"tags":[],"content":"由于您已经在本地拥有Quartz，因此不需要创建分支或克隆它。只需检出alpha分支，安装依赖项，然后导入旧的vault。\ngit fetch\ngit checkout v4\ngit pull upstream v4\nnpm i\nnpx quartz create\n如果您遇到类似 fatal: &#039;upstream&#039; does not appear to be a git repository的错误，请确保将upstream 添加为远端来源：\ngit remote add upstream github.com/jackyzha0/quartz.git\n当运行 npx quartz create,时，系统将提示您如何初始化内容文件夹。在这里，你可以选择导入或链接你以前的内容文件夹，Quartz应该能像你期望的那样工作。\n\n\n                  \n                  Note\n                  \n                \n如果要使用的存在内容文件夹位于不同分支上的同一路径，请在不同路径的某个位置再次克隆repo以使用它。\n\n关键变化\n\n删除Hugo和hugo-obsidian：Hugo在早期版本的Quartz中运行良好，但这也让Golang和Hugo社区以外的人很难完全了解Quartz在引擎盖下做了什么，并能够根据他们的需求进行适当的定制。Quartz 4现在使用基于节点的静态站点生成过程，这将导致更有用的错误消息和更流畅的用户体验。\n完全热更新：hugo-obsidian与hugo集成的许多粗糙边缘意味着观察模式不会重新触发hugo-obsidian 更新内容索引。这导致了许多观察模式输出不准确的奇怪情况。Quartz 4现在使用了一个内聚的解析、过滤和发送管道，它在每次更改时都会运行，因此热更新加载总是准确的。\n用JSX替换Go模板语法：Quartz 3使用Go templates以创建页面布局。然而，该语法不适合进行任何类型的复杂渲染（如文本处理)并且很难对Quartz 3进行任何有意义的布局更改。Quartz 4使用了一个名为JSX的JavaScript语法扩展，它允许您在JavaScript中编写看起来像HTML的布局代码，这明显更容易理解和维护。\n一个新的可扩展configuration和插件系统：Quartz 3在没有技术知识的情况下很难配置Hugo的部分是如何工作的。甚至很难去扩展。Quartz 4的配置和插件系统旨在由用户扩展，同时使更新到新版本的Quartz变得容易。\n\n需要更新的内容\n\n您将需要更新您的部署脚本。有关更多详细信息，请参阅hosting指南。\n确保您在GitHub上的默认分支已从“hugo”更新为“v4”。\nfolder and tag listings 也发生了更改。\n\n文件夹描述应位于content/&lt;folder-name&gt;/index.md 下，其中&lt;folder-name&gt;是文件夹的名称。\nTag 描述应位于content/tags/&lt;tag-name&gt;.md下，其中&lt;tag-name&gt; 是标记的名称。\n\n\nQuartz 3和Quartz 4之间的某些HTML布局可能不相同。如果您依赖于特定的HTML层次结构或类名，则可能需要更新自定义CSS以反映这些更改。\n如果您自定义了Quartz 3的布局，您可能需要将这些更改从Go模板转换回JSX，因为Quartz 4不再使用Hugo。对于组件，请查看有关创建组件的指南以了解更多详细信息。\n"},"philosophy":{"title":"Quartz的哲学","links":[],"tags":[],"content":"花园应该是一个真正的超文本\n\n花园就像一张网。每次穿过花园都会创造新的路径和意义，当我们在花园里添加东西时，我们会以一种允许许多未来的、不可预测的关系的方式添加它们。\n(花园与溪流)\n\n文件柜的问题在于，它关注的是访问效率和互操作性，而不是生成性和创造性。思维不是线性的，也不是层次性的。事实上，并没有多少事情是线性的或分层的。那么，为什么大多数工具和思维策略对我的思维过程都有一个很好的时间顺序或层次顺序呢？\n对我来说，理想的思考工具是拥抱我混乱的头脑，有机地帮助见解从混乱中产生，而不是强迫一种人为的秩序。一种根茎状的，非树状的笔记形式。\n我对数字花园的目标不仅仅是作为一个组织系统和信息存储（尽管它很好地实现了这一点）。我希望我的数字花园成为一个游乐场，以新的方式将想法联系在一起。因此，现有的正式组织系统，如Zettelkasten或Notion的分层文件夹结构，对我来说并不适用。前期有太多的摩擦，当我考虑如何将我的想法组织到文件夹类别中时，我已经失去了它。\nQuartz拥抱了我们思维中固有的根茎和网状本质，并试图鼓励以类似的形式记笔记。\n\n花园应该被分享的\n数字园艺的目标应该是利用网络的集体智慧来创建建设性的反馈回路。如果做得好，我可以分享我的想法，我可以把它传播到世界上，人们也可以做出回应。即使是对于我最不成熟的想法，这也有助于我创建一个反馈循环，以加强并充分的充实这个想法。\nQuartz首先被设计为一种发表数字花园到网络的工具。对我来说，数字园艺不仅仅是被动的知识收集。这是一种表达和分享的形式。\n\n“开门工作的人会受到各种各样的干扰，但他们偶尔也会得到关于世界是什么以及什么可能是重要的线索。”\n——理查德·汉明\n\nQuartz的目标是让共享您的数字花园变得免费而简单\n\n花园应该是你自己的\nQuartz的核心是设计得足够容易使用，让非技术人员能够开始工作，但功能也足够强大，高级开发人员可以对其进行调整，使其按照他们希望的方式工作。\n\n如果你喜欢Quartz的默认配置，只想更改内容，那么你唯一需要更改的就是 content 文件夹的内容。\n如果你想进行基本的配置调整，但又不想编辑源代码，可以根据自己的喜好，按照阐明的方式调整quartz.config.ts 和quartz.layout.ts中的插件和组件。\n如果你想调整底层插件、组件甚至构建过程的实际源代码，Quartz会有目的地将其完整源代码提供给最终用户，以允许在这个级别进行自定义。\n\n大多数软件要么将您限制为：\n\n轻松调整内容，但不调整演示文稿\n如果没有好的固执己见的默认值，会给你太多的旋钮来调整演示文稿\n\nQuartz应该感觉很强大，但最终是一个完全在您控制范围内的直观工具。 它应该是一个代理软件. 最终，它应该有正确的可用性来推动用户使用良好的默认值，但永远不要规定什么是“正确”的使用方式。"},"plugins/AliasRedirects":{"title":"AliasRedirects","links":["configuration"],"tags":["plugin/emitter"],"content":"这个插件为内容文件元数据定义的别名和永久链接生成HTML重定向页面。\n例如，foo.md 具有以下元数据\nfoo.md---\ntitle: &quot;Foo&quot;\nalias:\n  - &quot;bar&quot;\n---\n目标host.me/bar将重定向到`host.me/foo“\n请注意，这些是永久重定向。\n生成器支持以下别名：\n\naliases\nalias\n\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\nAPI\n\n分类: 生成器\n函数名: Plugin.AliasRedirects().\n源码: quartz/plugins/emitters/aliases.ts.\n"},"plugins/Assets":{"title":"Assets","links":["configuration"],"tags":["plugin/emitter"],"content":"这个插件会在您的内容文件夹中生成所有非Markdown静态资产（如图像、视频、HTML等）。该插件支持全局configuration中的ignorePatterns.\n请注意，所有静态资产都可以通过其在您生成的网站上的路径访问，即：host.me/path/to/static.pdf\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\nAPI\n\n分类: 生成器\n函数名: Plugin.Assets().\n源码: quartz/plugins/emitters/assets.ts.\n"},"plugins/CNAME":{"title":"CNAME","links":["hosting","configuration"],"tags":["plugin/emitter"],"content":"此插件生成一个“CNAME”记录，将您的子域指向网站的默认域。\n如果你想为网站使用一个自定义域名，比如quartz.example.com，那么这是必要的。\n查看hosting了解更多信息。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\nAPI\n\n分类: 生成器\n函数名: Plugin.CNAME().\n源码: quartz/plugins/emitters/cname.ts.\n"},"plugins/ComponentResources":{"title":"ComponentResources","links":["configuration"],"tags":["plugin/emitter"],"content":"这个插件管理并发布Quartz框架所需的静态资源。其中包括CSS样式表和JavaScript脚本，这些脚本增强了生成的网站的功能和美观性。另请参阅configurationtheme 部分中的cdnCaching选项。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\nAPI\n\n分类: 生成器\n函数名: Plugin.ComponentResources().\n源码: quartz/plugins/emitters/componentResources.ts.\n"},"plugins/ContentIndex":{"title":"ContentIndex","links":["RSS订阅","configuration"],"tags":["plugin/emitter"],"content":"这个插件为您的站点同时发出RSS和XML站点地图。RSS订阅 允许用户订阅您网站上的内容，网站地图允许搜索引擎更好地为您的网站编制索引。该插件还发出一个contentIndex.json 文件，供搜索和图形等动态前端组件使用。\n这个插件生成网站内容的综合索引，生成额外的资源，如网站地图、RSS提要和\n\n\n                  \n                  Note\n                  \n                \nFor information on how to add, remove or configure plugins, see the Configuration page.\n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\nenableSiteMap: 如果为true （默认值），则生成一个站点地图XML文件（sitemap.xml），列出内容发现中搜索引擎的所有站点URL。\nenableRSS: 如果为true （默认值），则生成包含最新内容更新的RSS提要（index.xml）。\nrssLimit: 定义RSS提要中包含的最大条目数，有助于关注最新或相关的内容。默认为“10”。\nrssFullHtml: 如果为true，则RSS提要包含完整的HTML内容。否则，它只包括摘要。\nincludeEmptyFiles: 如果为true（默认值），则不包含正文的内容文件将包含在生成的索引和资源中。\n\nAPI\n\n分类: 生成器\n函数名: Plugin.ContentIndex().\n源码: quartz/plugins/emitters/contentIndex.ts.\n"},"plugins/ContentPage":{"title":"ContentPage","links":["layout","configuration"],"tags":["plugin/emitter"],"content":"这个插件是Quartz框架的核心组件。它为每一条Markdown内容生成HTML页面。它生成整页layout, 包括页眉、页脚和正文内容等。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\nAPI\n\n分类: 生成器\n函数名: Plugin.ContentPage().\n源码: quartz/plugins/emitters/contentPage.tsx.\n"},"plugins/CrawlLinks":{"title":"CrawlLinks","links":["features/Obsidian-compatibility","configuration"],"tags":["plugin/transformer"],"content":"这个插件解析链接并处理它们以指向正确的位置。嵌入式链接（如图像）也需要它。参见Obsidian compatibility了解更多信息。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\n设置解析Markdown路径的策略，可以是“绝对”、“相对”或“最短”。您应该在此处使用与Obsidian中相同的设置。\n\nabsolute: 相对于内容文件夹根的路径。\nrelative: 相对于要链接的文件的路径。\nshortest: 文件的名称。如果这还不足以识别文件，请使用完整的绝对路径。\n\n\nprettyLinks: 如果为true（默认值），则通过删除文件夹路径简化链接，使其更便于用户使用（例如，folder/deeply/nested/note变为note）。\nopenLinksInNewTab: 如果为true，则将外部链接配置为在新选项卡中打开。默认值为false。\nlazyLoad: 如果是true，则向资源元素（“img”、“video”等）添加延迟加载，以提高页面加载性能。默认为false。\nexternalLinkIcon: 当为true（默认值）时，在外部链接旁边添加一个图标，以便在视觉上将它们与内部链接区分开来。\n\n\n\n                  \n                  Warning\n                  \n                \n不建议删除此插件，这可能会破坏页面。\n\nAPI\n\n分类: 转换器\n函数名: Plugin.CrawlLinks().\n源码: quartz/plugins/transformers/links.ts.\n"},"plugins/CreatedModifiedDate":{"title":"CreatedModifiedDate","links":["authoring-content","configuration","hosting"],"tags":["plugin/transformer"],"content":"该插件使用三个潜在的数据源来确定文档的创建、修改和发布日期：前端元数据、Git历史记录和文件系统。查看 创作内容 了解详细信息。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\npriority: 要查询日期信息的数据源。最高优先级优先。可能的值有&quot;frontmatter&quot;、&quot;git&quot;和&quot;filesystem&quot;.。默认为[&quot;frontmatter&quot;, &quot;git&quot;, &quot;filesystem&quot;]。\n\n\n\n                  \n                  Warning\n                  \n                \nquartz.config.ts.如果日期依赖git，请确保在quartz.config.ts中将defaultDateType 设置为modified 。\n本地文件的filesystem 日期可能与最终日期不匹配，这取决于你怎样hosting您的Quartz。在这种情况下，最好使用git 或 frontmatter来保证日期正确。\n\nAPI\n\n分类: 转换器\n函数名: Plugin.CreatedModifiedDate().\n源码: quartz/plugins/transformers/lastmod.ts.\n"},"plugins/Description":{"title":"Description","links":["RSS订阅","features/folder-and-tag-listings","authoring-content","configuration"],"tags":["plugin/transformer"],"content":"此插件生成的描述用作HTMLhead的元数据，RSS订阅 和folder and tag listings 中如果没有正文内容，则使用描述作为标题和列表之间的文本。\n如果元数据中包含 description 属性，则使用它（请参见创作内容）。否则，插件将尽最大努力使用内容的前几句话来达到目标描述长度。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\ndescriptionLength: 生成的描述的最大长度。默认值为150个字符。截断发生在第一个内容之后，该内容在给定长度之后结束。\nreplaceExternalLinks: 如果为true （默认值），则用描述中的域和路径替换外部链接（例如domain.tld/some_page/another_page替换为domain.tld/some_page/aother_page）。\n\nAPI\n\n分类: 转换器\n函数名: Plugin.Description().\n源码: quartz/plugins/transformers/description.ts.\n"},"plugins/ExplicitPublish":{"title":"ExplicitPublish","links":["plugins/RemoveDrafts","features/private-pages","configuration"],"tags":["plugin/filter"],"content":"该插件基于元数据中的显式publish标志过滤内容，只允许明确标记为发布的内容通过。这是RemoveDrafts的选择加入版本。查看private pages了解更多信息。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\nAPI\n\n分类: 过滤器\n函数名: Plugin.ExplicitPublish().\n源码: quartz/plugins/filters/explicit.ts.\n"},"plugins/FolderPage":{"title":"FolderPage","links":["features/folder-and-tag-listings","高级/","configuration"],"tags":["plugin/emitter"],"content":"This plugin generates index pages for folders, creating a listing page for each folder that contains multiple content files. See folder and tag listings for more information.\n此插件为文件夹生成索引页，为包含多个内容文件的每个文件夹创建一个列表页。查看folder and tag listings了解更多信息。\n举例: 高级\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\n这些页面是使用quarter.layouts.ts中的defaultListPageLayout显示。对于内容，将使用FolderContent组件。如果要修改布局，必须直接对其进行编辑（quartz/components/pages/FolderContent.tsx）。\nAPI\n\n分类: 生成器\n函数名: Plugin.FolderPage().\n源码: quartz/plugins/emitters/folderPage.tsx.\n"},"plugins/Frontmatter":{"title":"Frontmatter","links":["authoring-content","features/Obsidian-compatibility","features/OxHugo-compatibility","configuration"],"tags":["plugin/transformer"],"content":"This plugin parses the frontmatter of the page using the gray-matter library. See Syntax, Obsidian compatibility and OxHugo compatibility for more information.\n这个插件使用 gray-matter 库解析页面的元数据，Obsidian compatibility 和OxHugo compatibility 了解更多信息。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\ndelimiters: 用于标题的分隔符。可以有一个值（例如&quot;---&quot;），也可以有单独的值用于打开和关闭分隔符（例如[&quot;---&quot;, &quot;~~~&quot;]）。默认为&quot;---&quot;。\nlanguage: 用于解析元数据的语言。可以是yaml （默认值）或toml。\n\n\n\n                  \n                  Warning\n                  \n                \n此插件不得删除，否则Quartz将损坏。\n\nAPI\n\n分类: 转换器\n函数名: Plugin.Frontmatter().\n源码: quartz/plugins/transformers/frontmatter.ts.\n"},"plugins/GitHubFlavoredMarkdown":{"title":"GitHubFlavoredMarkdown","links":["configuration"],"tags":["plugin/transformer"],"content":"该插件增强了Markdown处理，以支持GitHub风格的Markdown（GFM），它添加了自动链接文字、脚注、删除线、表和任务列表等功能。\n此外，该插件还添加了可选的排版优化功能（如将直引号转换为花引号，将短划线转换为英文短划线和省略号），并将自动标题链接作为悬停时显示在标题旁边的符号。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\nenableSmartyPants: 如果为true，则启用排版增强功能。默认值为true。\nlinkHeadings: 如果为true，则自动向标题添加链接。默认值为true。\n\nAPI\n\n分类: 转换器\n函数名: Plugin.GitHubFlavoredMarkdown().\n源码: quartz/plugins/transformers/gfm.ts.\n"},"plugins/HardLineBreaks":{"title":"HardLineBreaks","links":["features/Obsidian-compatibility","configuration"],"tags":["plugin/transformer"],"content":"该插件自动将Markdown文本中的换行符转换为HTML输出中的硬换行符。默认情况下，此插件未启用，因为它不符合实际Markdown的语义，但如果您希望与Obsidian 一样，你可以将它开启。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\nAPI\n\n分类: 转换器\n函数名: Plugin.HardLineBreaks().\n源码: quartz/plugins/transformers/linebreaks.ts.\n"},"plugins/Latex":{"title":"Latex","links":["features/Latex","configuration"],"tags":["plugin/transformer"],"content":"此插件为Quartz添加了对LaTeX的支持。查看Latex了解更多信息。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\nrenderEngine: the engine to use to render LaTeX equations. Can be &quot;katex&quot; for KaTeX or &quot;mathjax&quot; for MathJax SVG rendering. Defaults to KaTeX.用于渲染LaTeX方程的引擎。可以是KaTeX 的&quot;katex&quot;或MathJaxSVG rendering的&quot;mathjax&quot;。 默认为KaTeX。\n\nAPI\n\n分类: 转换器\n函数名 Plugin.Latex().\n源码: quartz/plugins/transformers/latex.ts.\n"},"plugins/NotFoundPage":{"title":"NotFoundPage","links":["configuration"],"tags":["plugin/emitter"],"content":"此插件为损坏或不存在的URL发出404（未找到）页面。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\nAPI\n\n分类: 生成器\n函数名 Plugin.NotFoundPage().\n源码: quartz/plugins/emitters/404.tsx.\n"},"plugins/ObsidianFlavoredMarkdown":{"title":"ObsidianFlavoredMarkdown","links":["features/Obsidian-compatibility","configuration","features/wikilinks","features/callouts","features/Mermaid-diagrams"],"tags":["plugin/transformer"],"content":"此插件提供对Obsidian compatibility支持。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\ncomments: 如果为true（默认值），则启用对%%样式的Obsidian注释块的分析。\nhighlight: 如果为true（默认值），则启用对内容中==样式高亮显示的解析。\nwikilinks: 如果为true（默认值），则转到wikilinks 转换为常规链接。\ncallouts: 如果为true（默认值），则添加对的支持callout块，用于强调内容。\nmermaid: 如果为true（默认值），则启用Mermaid diagrams在Markdown文件中渲染。\nparseTags: 如果为true （默认值），则解析并链接内容中的标签。\nparseArrows: 如果为true （默认值），则将箭头符号转换为等效的HTML字符。\nparseBlockReferences: 如果为true （默认值），则处理块引用，链接到特定的内容块。\nenableInHtmlEmbed: 如果为true,，则允许直接在HTML中嵌入内容。默认为false。\nenableYouTubeEmbed: 如果true（默认值），则启用使用外部图像Markdown语法嵌入YouTube视频和播放列表。\nenableVideoEmbed: 如果为true （默认值），则启用视频文件的嵌入。\nenableCheckbox: 如果为true，则添加对内容中交互式复选框的支持。默认为false.。\n\n\n\n                  \n                  Warning\n                  \n                \n请不要移除这个插件，如果您正在使用Obsidian 来编写内容！\n\nAPI\n\n分类: 转换器\n函数名 Plugin.ObsidianFlavoredMarkdown().\n源码: quartz/plugins/transformers/toc.ts.\n"},"plugins/OxHugoFlavoredMarkdown":{"title":"OxHugoFlavoredMarkdown","links":["features/OxHugo-compatibility","configuration","features/wikilinks","features/Latex","plugins/ObsidianFlavoredMarkdown","plugins/Frontmatter"],"tags":["plugin/transformer"],"content":"此插件提供对ox-hugo 兼容性的支持。参见OxHugo compatibility 了解更多信息。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\nwikilinks: 如果为 true （默认值），则将Hugo的 {{ relref }} 短代码转换为Quartzwikilinks.\nremovePredefinedAnchor: 如果为true （默认值），则从标题中删除预定义的锚点。\nremoveHugoShortcode: 如果为true（默认值），则从内容中删除Hugo短代码语法（{{}}）。\nreplaceFigureWithMdImg:  如果为true （默认值），则将&lt;figure/&gt;替换为![]().\nreplaceOrgLatex: 如果为 true（默认值），则将Org模式Latex 片段转换为封装在$（用于内联）和 $$（用于块方程）中的Quartz兼容LaTeX。\n\n\n\n                  \n                  Warning\n                  \n                \n你可以将其与ObsidianFlavoredMarkdown一起使用，但不建议这样做，因为它可能会以意想不到的方式对文件进行变异。小心使用。\n如果使用tomlfrontmatter，请确保配置Frontmatter 插件。参见OxHugo compatibility 例如。\n\nAPI\n\n分类: 转换器\n函数名: Plugin.OxHugoFlavoredMarkdown().\n源码: quartz/plugins/transformers/oxhugofm.ts.\n"},"plugins/RemoveDrafts":{"title":"RemoveDrafts","links":["features/private-pages","configuration"],"tags":["plugin/filter"],"content":"此插件从您的vault中筛选出内容，以便只提供最终确定的内容。这样可以防止private pages禁止发布。默认情况下，它会过滤掉标题中带有draft: true 的所有页面，并保留所有其他页面不变。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\nAPI\n\n分类: 过滤器\n函数名: Plugin.RemoveDrafts().\n源码: quartz/plugins/filters/draft.ts.\n"},"plugins/Static":{"title":"Static","links":["configuration","plugins/Assets","plugins/Static"],"tags":["plugin/emitter"],"content":"这个插件生成Quartz所需的所有静态资源。例如，这用于需要稳定位置的字体和图像，如横幅和图标。该插件不违背全局configuration中的ignorePatterns 。\n\n\n                  \n                  Important\n                  \n                \n这与Assets不同。来自Static 插件的资源位于quartz/static下，而Assets 是出现在content下的所有静态资源，并用于您的markdown内容直接引用的图像、视频、音频等。\n\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\nAPI\n\n分类: 生成器\n函数名: Plugin.Static().\n源码: quartz/plugins/emitters/static.ts.\n"},"plugins/SyntaxHighlighting":{"title":"SyntaxHighlighting","links":["features/syntax-highlighting","configuration"],"tags":["plugin/transformer"],"content":"该插件用于为Quartz中的代码块添加语法高亮显示。参见 syntax highlighting了解更多信息。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\ntheme: 一个与Shikiji捆绑在一起的主题的独立id。一个用于亮模式，一个用于暗模式。默认为theme: { light: &quot;github-light&quot;, dark: &quot;github-dark&quot; }。\nkeepBackground: 如果设置为true，将使用Shikiji主题的背景。使用false （默认值）时，将使用Quartz主题颜色作为背景。\n\n此外，您还可以进一步覆盖quartz/styles/syntax.scss文件中的颜色。\nAPI\n\n分类: 转换器\n函数名: Plugin.SyntaxHighlighting().\n源码: quartz/plugins/transformers/syntax.ts.\n"},"plugins/TableOfContents":{"title":"TableOfContents","links":["features/table-of-contents","configuration"],"tags":["plugin/transformer"],"content":"这个插件为Markdown文档生成一个目录（TOC）。参看table of contents了解更多信息。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件接受以下配置选项：\n\nmaxDepth: 限制目录中所列标题的深度，范围从1（仅限顶级标题）到6（所有标题级别）。默认值为3。\nminEntries: 显示目录所需的最小标题条目数。默认值为`1。\nshowByDefault: 如果true（默认值），则默认情况下应显示TOC。可以被元数据设置覆盖。\ncollapseByDefault: 如果true，TOC将以折叠状态开始。默认值为false。\n\n\n\n                  \n                  Warning\n                  \n                \n此插件需要Component.TableOfContents组件，以确定在何处显示TOC。没有它，什么都不会显示。应始终将它们在一起添加或删除。\n\nAPI\n\n分类: 转换器\n函数名: Plugin.TableOfContents().\n源码: quartz/plugins/transformers/toc.ts.\n"},"plugins/TagPage":{"title":"TagPage","links":["features/folder-and-tag-listings","configuration"],"tags":["plugin/emitter"],"content":"这个插件为内容中使用的每个标签发出专用页面。参看folder and tag listings了解更多信息。\n\n\n                  \n                  Note\n                  \n                \n有关如何添加、删除或配置插件的信息，请参阅配置页。\n\n此插件没有配置选项。\n这些页面是使用quarter.layouts.ts中的defaultListPageLayout显示。对于内容，将使用TagContent组件。如果要修改布局，必须直接编辑（quarter/components/pages/TagContent.tsx）。\nAPI\n\n分类: 生成器\n函数名: Plugin.TagPage().\n源码: quartz/plugins/emitters/tagPage.tsx.\n"},"plugins/index":{"title":"插件列表","links":[],"tags":[],"content":""},"setting-up-your-GitHub-repository":{"title":"设置GitHub仓库","links":["/"],"tags":[],"content":"First, make sure you have Quartz cloned and setup locally.\n首先，确保您有Quartz克隆并在本地安装。\n然后，在GitHub.com上创建一个新的存储库。不要使用“README”、许可证或“gitignore”文件初始化新存储库。\n\n在GitHub.com的“Quick Setup”页面上的存储库顶部，单击clipboard复制远程仓库地址。\n\n在您选择的终端中，导航到Quartz文件夹的根目录。然后，运行以下命令，将REMOTE-URL替换为您刚刚从上一步复制的URL。\n# list all the repositories that are tracked\ngit remote -v\n \n# if the origin doesn&#039;t match your own repository, set your repository as the origin\ngit remote set-url origin REMOTE-URL\n \n# if you don&#039;t have upstream as a remote, add it so updates work\ngit remote add upstream github.com/jackyzha0/quartz.git\n然后，您可以同步内容以将其上传到仓库。这是一个助手命令，用于将内容初始推送到存储库。\nnpx quartz sync --no-pull\n\n\n                  \n                   fatal: --[no-]autostash option is only valid with --rebase\n                  \n                \n你可能有一个过时的git.版本。更新git.应该可以解决此问题。\n\n在未来的更新中，每次您想将更新推送到存储库时，只需运行 npx quartz sync 即可。\n\n\n                  \n                  Flags and options \n                  \n                \n有关完整帮助选项，您可以运行npx-quarter-sync--help。\n其中大多数都有合理的默认值，但如果您有自定义设置，则可以覆盖它们：\n\n-d or --directory:  content内容文件夹。默认是`content“\n-v or --verbose: 打印出额外的日志信息\n--commit or --no-commit: 是否对您的更改进行 git 提交\n--push or --no-push: 是否将更新推送到Quartz的GitHub分支\n--pull or --no-pull: 在推送之前，是否尝试从你的GitHub（即从其他设备）获取任何更新\n\n"},"showcase":{"title":"Quartz 案例","links":[],"tags":[],"content":"想看看Quartz能做什么吗？以下是一些很酷的社区花园：\n\nQuartz Documentation (this site!)\nJacky Zhao’s Garden\nSocratica Toolbox\noldwinter の数字花园\nAaron Pham’s Garden\nThe Quantum Garden\nAbhijeet’s Math Wiki\nMatt Dunn’s Second Brain\nPelayo Arbues’ Notes\nVince Imbat’s Talahardin\n🧠🌳 Chad’s Mind Garden\nPedro MC Fernandes’s Topo da Mente\nMau Camargo’s Notkesto\nCaicai’s Novels\n🌊 Collapsed Wave\nSideny’s 3D Artist’s Handbook\nMike’s AI Garden 🤖🪴\nBrandon Boswell’s Garden\nScaling Synthesis - A hypertext research notebook\nData Dictionary 🧠\nsspaeti.com’s Second Brain\n🪴Aster’s notebook\n🥷🏻🌳🍃 Computer Science &amp; Thinkering Garden\n\n如果你想在这里看到你自己的，请提交一个Pull Request将你自己添加到此文件!"},"tags/component":{"title":"组件","links":["创建组件"],"tags":[],"content":"想要创建自己的自定义组件吗？有关详细信息，请查看有关创建组件的高级指南。"},"tags/plugin":{"title":"插件","links":[],"tags":[],"content":""},"upgrading":{"title":"升级 Quartz","links":["migrating-from-Quartz-3"],"tags":[],"content":"\n\n                  \n                  Note\n                  \n                \n这是一个专门用于将Quartz 4版本升级到最新更新的指南。如果您来自Quartz 3，请查看迁移指南了解更多信息。\n\n要获取最新的Quartz更新，只需运行\nnpx quartz update\nQuartz使用git在版本控制的框架下，从官方Quartz GitHub仓库中拉取更新。如果您的更新与本地更改冲突，您可能需要自己手动解决这些问题（或者，使用git pull origin upstream手动拉取）。\n\n\n                  \n                  Hint\n                  \n                \nQuartz将尝试在更新前缓存您的内容，以防止合并冲突。如果在合并过程中遇到冲突，可以停止合并，然后运行npx quartz restore 从缓存中恢复内容。\n\n如果你有GitHub桌面应用程序，这将自动打开以帮助您解决冲突。否则，您将需要在像VSCode这样的文本编辑器中解决此问题。有关手动解决冲突的更多帮助，请查看GitHub解决合并冲突指南。"}}